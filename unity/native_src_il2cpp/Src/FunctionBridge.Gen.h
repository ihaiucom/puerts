

// Auto Gen

#if !__SNC__
#ifndef __has_feature 
#define __has_feature(x) 0 
#endif
#endif

#if _MSC_VER
typedef wchar_t Il2CppChar;
#elif __has_feature(cxx_unicode_literals)
typedef char16_t Il2CppChar;
#else
typedef uint16_t Il2CppChar;
#endif

// Vector2
struct s_r4r4_
{
    float p0;
    float p1;
};
    
// Vector3
struct s_r4r4r4_
{
    float p0;
    float p1;
    float p2;
};
    
// Vector4
struct s_r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
};
    
// Bounds
struct s_r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
};
    
// RaycastHit
struct s_r4r4r4r4r4r4u4r4r4r4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    uint32_t p6;
    float p7;
    float p8;
    float p9;
    int32_t p10;
};
    
// Matrix4x4
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
};
    
// MainModule
struct s_o_
{
    void* p0;
};
    
// Mathf
struct s__
{
};
    
// RenderRequest
struct s_i4oi4_
{
    int32_t p0;
    void* p1;
    int32_t p2;
};
    
// Scene
struct s_i4_
{
    int32_t p0;
};
    
// LightBakingOutput
struct s_i4i4i4i4b_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    bool p4;
};
    
// NativeArray`1
struct s_Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
};
    
// SubMeshDescriptor
struct s_r4r4r4r4r4r4i4i4i4i4i4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    int32_t p6;
    int32_t p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
};
    
// MeshDataArray
struct s_Ppi4i4i4pi4i4o_
{
    void** p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
};
    
// GlobalKeyword
struct s_su4_
{
    void* p0;
    uint32_t p1;
};
    
// Hash128
struct s_u8u8_
{
    uint64_t p0;
    uint64_t p1;
};
    
// LocalKeyword
struct s_psu4_
{
    void* p0;
    void* p1;
    uint32_t p2;
};
    
// MinMaxCurve
struct s_i4r4oor4r4_
{
    int32_t p0;
    float p1;
    void* p2;
    void* p3;
    float p4;
    float p5;
};
    
// MinMaxGradient
struct s_i4oor4r4r4r4r4r4r4r4_
{
    int32_t p0;
    void* p1;
    void* p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
};
    
// Keyframe
struct s_r4r4r4r4i4i4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    int32_t p4;
    int32_t p5;
    float p6;
    float p7;
};
    
// DisplayInfo
struct s_u8i4i4u4u4i4i4i4i4s_
{
    uint64_t p0;
    int32_t p1;
    int32_t p2;
    uint32_t p3;
    uint32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
    int32_t p8;
    void* p9;
};
    
// Vector2Int
struct s_i4i4_
{
    int32_t p0;
    int32_t p1;
};
    
// RenderTextureDescriptor
struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
};
    
// RenderBuffer
struct s_i4p_
{
    int32_t p0;
    void* p1;
};
    
// GateFitParameters
struct s_i4r4_
{
    int32_t p0;
    float p1;
};
    
// ScriptableCullingParameters
struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    int32_t p7;
    uint8_t p8;
    int32_t p9;
    uint32_t p10;
    uint64_t p11;
    float p12;
    int32_t p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    float p24;
    float p25;
    float p26;
    float p27;
    float p28;
    float p29;
    float p30;
    float p31;
    float p32;
    float p33;
    float p34;
    int32_t p35;
    int32_t p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    float p56;
    float p57;
    float p58;
    float p59;
    float p60;
    float p61;
    float p62;
    float p63;
    float p64;
    float p65;
    float p66;
    float p67;
    float p68;
    float p69;
    float p70;
    float p71;
    float p72;
    float p73;
    float p74;
    float p75;
    float p76;
    float p77;
    float p78;
    float p79;
    float p80;
    float p81;
    float p82;
    float p83;
    float p84;
    float p85;
    float p86;
    float p87;
    float p88;
    float p89;
    float p90;
    float p91;
    float p92;
    float p93;
    float p94;
    float p95;
    float p96;
    float p97;
    float p98;
    float p99;
    float p100;
    float p101;
    float p102;
    float p103;
    float p104;
    float p105;
    float p106;
    float p107;
    float p108;
    float p109;
    float p110;
    float p111;
    float p112;
    float p113;
    float p114;
    float p115;
    float p116;
    float p117;
    float p118;
    float p119;
    float p120;
    float p121;
    float p122;
    float p123;
    float p124;
    float p125;
    float p126;
    float p127;
    float p128;
    float p129;
    float p130;
    float p131;
    float p132;
    float p133;
    float p134;
    float p135;
    float p136;
    float p137;
    float p138;
    float p139;
    float p140;
    float p141;
    float p142;
    float p143;
    float p144;
    float p145;
    float p146;
    float p147;
    float p148;
    float p149;
    float p150;
    float p151;
    float p152;
    float p153;
    float p154;
    float p155;
    float p156;
    float p157;
    float p158;
    float p159;
    float p160;
    float p161;
    float p162;
    float p163;
    float p164;
    float p165;
    float p166;
    float p167;
    float p168;
    float p169;
    float p170;
    float p171;
    float p172;
    float p173;
    float p174;
    float p175;
    float p176;
    float p177;
    float p178;
    float p179;
    float p180;
    float p181;
    float p182;
    float p183;
    float p184;
    float p185;
    float p186;
    float p187;
    float p188;
    float p189;
    float p190;
    float p191;
    float p192;
    uint32_t p193;
    uint8_t p194;
    uint8_t p195;
    float p196;
    float p197;
    float p198;
    float p199;
    float p200;
    int32_t p201;
    int32_t p202;
    uint32_t p203;
    int32_t p204;
    uint32_t p205;
    int32_t p206;
    int32_t p207;
    float p208;
    int32_t p209;
    float p210;
    float p211;
    float p212;
    float p213;
    float p214;
    float p215;
    float p216;
    float p217;
    float p218;
    float p219;
    float p220;
    float p221;
    float p222;
    float p223;
    float p224;
    float p225;
    float p226;
    float p227;
    float p228;
    float p229;
    float p230;
    float p231;
    float p232;
    float p233;
    float p234;
    float p235;
    float p236;
    float p237;
    float p238;
    float p239;
    float p240;
    float p241;
    float p242;
    int32_t p243;
    bool p244;
    int32_t p245;
};
    
// PlaybackState
struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_
{
    float p0;
    float p1;
    float p2;
    int32_t p3;
    float p4;
    float p5;
    uint32_t p6;
    uint32_t p7;
    uint32_t p8;
    uint32_t p9;
    uint32_t p10;
    uint32_t p11;
    uint32_t p12;
    uint32_t p13;
    uint32_t p14;
    uint32_t p15;
    uint32_t p16;
    uint32_t p17;
    uint32_t p18;
    uint32_t p19;
    uint32_t p20;
    uint32_t p21;
    uint32_t p22;
    uint32_t p23;
    uint32_t p24;
    uint32_t p25;
    uint32_t p26;
    uint32_t p27;
    uint32_t p28;
    uint32_t p29;
    uint32_t p30;
    uint32_t p31;
    uint32_t p32;
    uint32_t p33;
    uint32_t p34;
    uint32_t p35;
    uint32_t p36;
    uint32_t p37;
    uint32_t p38;
    uint32_t p39;
    uint32_t p40;
    uint32_t p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    int32_t p48;
    uint32_t p49;
    uint32_t p50;
    uint32_t p51;
    uint32_t p52;
    uint32_t p53;
    uint32_t p54;
    uint32_t p55;
    uint32_t p56;
    uint32_t p57;
    uint32_t p58;
    uint32_t p59;
    uint32_t p60;
    uint32_t p61;
    uint32_t p62;
    uint32_t p63;
    uint32_t p64;
    uint32_t p65;
    uint32_t p66;
    uint32_t p67;
    uint32_t p68;
    uint32_t p69;
    uint32_t p70;
    uint32_t p71;
    uint32_t p72;
    uint32_t p73;
    uint32_t p74;
    uint32_t p75;
    uint32_t p76;
    uint32_t p77;
    uint32_t p78;
    uint32_t p79;
    uint32_t p80;
    float p81;
    uint32_t p82;
    uint32_t p83;
    uint32_t p84;
    uint32_t p85;
    float p86;
    float p87;
};
    
// Trails
struct s_ooooi4i4_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    int32_t p4;
    int32_t p5;
};
    
// EmitParams
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    int32_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint32_t p29;
    uint32_t p30;
    float p31;
    float p32;
    int32_t p33;
    float p34;
    float p35;
    uint32_t p36;
    bool p37;
    bool p38;
    bool p39;
    bool p40;
    bool p41;
    bool p42;
    bool p43;
    bool p44;
    bool p45;
    bool p46;
    bool p47;
};
    
// Particle
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    int32_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint32_t p29;
    uint32_t p30;
    float p31;
    float p32;
    int32_t p33;
    float p34;
    float p35;
    uint32_t p36;
};
    
// Void
struct v
{
};
    
// TextGenerationSettings
struct s_or4r4r4r4i4r4br4i4i4bbi4i4bi4i4r4r4r4r4b_
{
    void* p0;
    float p1;
    float p2;
    float p3;
    float p4;
    int32_t p5;
    float p6;
    bool p7;
    float p8;
    int32_t p9;
    int32_t p10;
    bool p11;
    bool p12;
    int32_t p13;
    int32_t p14;
    bool p15;
    int32_t p16;
    int32_t p17;
    float p18;
    float p19;
    float p20;
    float p21;
    bool p22;
};
    
// VertexAttributeDescriptor
struct s_i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
};
    
// LocalKeywordSpace
struct s_p_
{
    void* p0;
};
    
// AnimatorStateInfo
struct s_i4i4i4r4r4r4r4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    float p3;
    float p4;
    float p5;
    float p6;
    int32_t p7;
    int32_t p8;
};
    
// AnimatorTransitionInfo
struct s_i4i4i4br4r4bi4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    bool p3;
    float p4;
    float p5;
    bool p6;
    int32_t p7;
};
    
// PlayableGraph
struct s_pu4_
{
    void* p0;
    uint32_t p1;
};
    
// ContactPoint
struct s_r4r4r4r4r4r4i4i4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    int32_t p6;
    int32_t p7;
    float p8;
};
    
// Resolution
struct s_i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
};
    
// Touch
struct s_i4r4r4r4r4r4r4r4i4i4i4r4r4r4r4r4r4_
{
    int32_t p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
};
    
// NativeOverlapped
struct s_ppi4i4p_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
    void* p4;
};
    
// StreamingContext
struct s_Oi4_
{
    void* p0;
    int32_t p1;
};
    
// Span`1
struct s_pi4_
{
    void* p0;
    int32_t p1;
};
    
// AsyncLocalValueChangedArgs`1
struct s_oob_
{
    void* p0;
    void* p1;
    bool p2;
};
    
// FileSystemEntry
struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_
{
    struct s_u4u4i8i8i8i8i8i8i4u4u4c_* p0;
    void* p1;
    int32_t p2;
    void* p3;
    int32_t p4;
    void* p5;
    int32_t p6;
};
    
// BatchCullingContext
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
    void* p18;
    int32_t p19;
    int32_t p20;
    int32_t p21;
    void* p22;
    int32_t p23;
    int32_t p24;
    void* p25;
    int32_t p26;
    void* p27;
    int32_t p28;
    int32_t p29;
    int32_t p30;
    void* p31;
    int32_t p32;
    int32_t p33;
    void* p34;
    int32_t p35;
    int32_t p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    int32_t p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    float p56;
    float p57;
    float p58;
    float p59;
};
    
// DateTime
struct s_u8_
{
    uint64_t p0;
};
    
// CullingGroupEvent
struct s_i4u1u1_
{
    int32_t p0;
    uint8_t p1;
    uint8_t p2;
};
    
// DebugScreenCapture
struct s_Pvi4i4i4pi4i4oi4i4i4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
};
    
// PhraseRecognizedEventArgs
struct s_i4osu8i8_
{
    int32_t p0;
    void* p1;
    void* p2;
    uint64_t p3;
    int64_t p4;
};
    
// PhotoCaptureResult
struct s_i4i8_
{
    int32_t p0;
    int64_t p1;
};
    
// ScriptableRenderContext
struct s_ppi4i4_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
};
    
// TimerState
struct s_i8i8_
{
    int64_t p0;
    int64_t p1;
};
    
// XRNodeState
struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    int32_t p21;
    uint64_t p22;
};
    
// InputDevice
struct s_u8b_
{
    uint64_t p0;
    bool p1;
};
    
// MeshGenerationResult
struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_
{
    uint64_t p0;
    uint64_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    int32_t p5;
    uint64_t p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
};
    
// BuildPlayerOptions
struct s_ossi4i4i4i4o_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    void* p7;
};
    
// CameraMode
struct s_i4ss_
{
    int32_t p0;
    void* p1;
    void* p2;
};
    
// ObjectChangeEventStream
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
};
    
// ActiveProfileChangedEventArgs
struct s_ss_
{
    void* p0;
    void* p1;
};
    
// ShortcutBindingChangedEventArgs
struct s_soo_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// AuthCodeResponse
struct s_so_
{
    void* p0;
    void* p1;
};
    
// ObjectSelectorTargetInfo
struct s_u8u8u4u4u4u4i4oo_
{
    uint64_t p0;
    uint64_t p1;
    uint32_t p2;
    uint32_t p3;
    uint32_t p4;
    uint32_t p5;
    int32_t p6;
    void* p7;
    void* p8;
};
    
// SubSceneInfo
struct s_oi4osi4u1u1u1u1_
{
    void* p0;
    int32_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
};
    
// TouchEvent
struct s_i4r4r4i4_
{
    int32_t p0;
    float p1;
    float p2;
    int32_t p3;
};
    
// NodeCreationContext
struct s_r4r4oi4_
{
    float p0;
    float p1;
    void* p2;
    int32_t p3;
};
    
// GraphViewChange
struct s_ooor4r4_
{
    void* p0;
    void* p1;
    void* p2;
    float p3;
    float p4;
};
    
// SearchColumnEventArgs
struct s_oooObr4r4r4r4bb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
};
    
// SearchColumnCompareArgs
struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
    void* p11;
    void* p12;
    void* p13;
    void* p14;
    bool p15;
    float p16;
    float p17;
    float p18;
    float p19;
    bool p20;
    bool p21;
    bool p22;
};
    
// SearchEvent
struct s_oo_
{
    void* p0;
    void* p1;
};
    
// EventHook
struct s_sOO_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// VFXOutputEventArgs
struct s_i4o_
{
    int32_t p0;
    void* p1;
};
    
// EditorCurveBinding
struct s_sosi4i4i4i4i4_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
};
    
// ParseResult`1
struct s_bo_
{
    bool p0;
    void* p1;
};
    
// Nullable`1
struct s_bi4_
{
    bool p0;
    int32_t p1;
};
    
// Nullable`1
struct s_bi8_
{
    bool p0;
    int64_t p1;
};
    
// Nullable`1
struct s_br4_
{
    bool p0;
    float p1;
};
    
// Nullable`1
struct s_br8_
{
    bool p0;
    double p1;
};
    
// Decimal
struct s_i4i4i4i4u8_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    uint64_t p4;
};
    
// Nullable`1
struct s_bi4i4i4i4u8_
{
    bool p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    uint64_t p5;
};
    


// Boolean get_developerConsoleVisible()
static bool w_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef bool (*FuncToCall)(const void* method);
    bool ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsKeywordEnabled(UnityEngine.Rendering.GlobalKeyword ByRef)
static bool w_bPs_su4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bPs_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct s_su4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)
static bool w_bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SupportsVertexAttributeFormat(UnityEngine.Rendering.VertexAttributeFormat, Int32)
static bool w_bi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bi4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Implicit(UnityEngine.Object)
static bool w_bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Object, UnityEngine.Object)
static bool w_boo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ComputePenetration(UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3 ByRef, Single ByRef)
static bool w_bos_r4r4r4_s_r4r4r4r4_os_r4r4r4_s_r4r4r4r4_Ps_r4r4r4_Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bos_r4r4r4_s_r4r4r4r4_os_r4r4r4_s_r4r4r4r4_Ps_r4r4r4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if ((!info[5]->IsObject() || !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>())))) return false;
        if (!info[6]->IsObject()) return false;
        if (!info[7]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal struct
    s_r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[4]);
    s_r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp5 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[5]);
    s_r4r4r4r4_ p5 = pp5 ? *pp5 : s_r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p6 = nullptr; // valuetype ref
    s_r4r4r4_ up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
        auto tp6 = op6->Get(context, 0).ToLocalChecked();
        p6 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp6);
    }
    if (!p6) {
        p6 = &up6;
    }
        
    // JSValToCSVal P primitive
    float up7 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[7]);
    float* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, struct s_r4r4r4_ p4, struct s_r4r4r4r4_ p5, struct s_r4r4r4_* p6, float* p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op6.IsEmpty() && p6 == &up6)
    {
        auto _unused = op6->Set(context, 0, CopyValueType(isolate, context, TIp6, p6, sizeof(*p6)));
    }
            
    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<float>::toScript(context, *p7));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetBooleanArrayElement(IntPtr, Int32)
static bool w_bpi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bpi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsAssignableFrom(IntPtr, IntPtr)
static bool w_bpp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bpp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef bool (*FuncToCall)(void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CallBooleanMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_bppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef bool (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Approximately(Single, Single)
static bool w_br4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_br4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(float p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsKeywordEnabled(System.String)
static bool w_bs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.Scene)
static bool w_bs_i4_s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4_s_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef bool (*FuncToCall)(struct s_i4_ p0, struct s_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_bs_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CheckSphere(UnityEngine.Vector3, Single)
static bool w_bs_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CheckSphere(UnityEngine.Vector3, Single, Int32)
static bool w_bs_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CheckSphere(UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, float p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)
static bool w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)
static bool w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32)
static bool w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_bs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)
static bool w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)
static bool w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, float p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Linecast(UnityEngine.Vector3, UnityEngine.Vector3, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_bs_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p4 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p4 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p4 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p4, float p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p4 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p4, float p5, int32_t p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CapsuleCast(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, struct s_r4r4r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, struct s_r4r4r4r4_ p4, float p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, struct s_r4r4r4r4_ p4, float p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsObject()) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p3, struct s_r4r4r4r4_ p4, float p5, int32_t p6, int32_t p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BoxCast(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CheckBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector4, UnityEngine.Vector4)
static bool w_bs_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray)
static bool w_bs_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef)
static bool w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single)
static bool w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single, Int32)
static bool w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, Single)
static bool w_bs_r4r4r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef)
static bool w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single)
static bool w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single, Int32)
static bool w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, float p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, UnityEngine.RaycastHit ByRef, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p2, float p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, Single, Int32)
static bool w_bs_r4r4r4r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, Single)
static bool w_bs_r4r4r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, Single, Int32)
static bool w_bs_r4r4r4r4r4r4_r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SphereCast(UnityEngine.Ray, Single, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_bs_r4r4r4r4r4r4_r4r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_r4r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, float p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Bounds, UnityEngine.Bounds)
static bool w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Inverse3DAffine(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4 ByRef)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean get_useColorTemperature()
static bool w_bt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef bool (*FuncToCall)(void*,const void* method);
    bool ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(System.Object)
static bool w_btO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetCullingParameters(UnityEngine.Rendering.ScriptableCullingParameters ByRef)
static bool w_btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p0 = nullptr; // valuetype ref
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsKeywordEnabled(UnityEngine.Rendering.LocalKeyword ByRef)
static bool w_btPs_psu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btPs_psu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_psu4_* p0 = nullptr; // valuetype ref
    s_psu4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_psu4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct s_psu4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsAlive(Boolean)
static bool w_btb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,bool p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetCullingParameters(Boolean, UnityEngine.Rendering.ScriptableCullingParameters ByRef)
static bool w_btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal Pstruct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p1 = nullptr; // valuetype ref
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void*,bool p0, struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsPointerOverGameObject(Int32)
static bool w_bti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean FindTextureStack(Int32, System.String ByRef, Int32 ByRef)
static bool w_bti4PsPi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4PsPi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Ps
    void* up1 = nullptr; // string ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        v8::String::Utf8Value tp1(isolate, op1->Get(context, 0).ToLocalChecked());
        up1 = CStringToCSharpString(*tp1);
    }
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[2]);
    int32_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void*,int32_t p0, void** p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSAnyToJsValue(isolate, context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean HasState(Int32, Int32)
static bool w_bti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsChildOf(UnityEngine.Transform)
static bool w_bto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetComponent(System.Type, UnityEngine.Component ByRef)
static bool w_btoPo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetData(Single[], Int32)
static bool w_btoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean RenderToCubemap(UnityEngine.RenderTexture, Int32, MonoOrStereoscopicEye)
static bool w_btoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean FileExists(System.String)
static bool w_bts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Vector2)
static bool w_bts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Vector3)
static bool w_bts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SweepTest(UnityEngine.Vector3, UnityEngine.RaycastHit ByRef)
static bool w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SweepTest(UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single)
static bool w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SweepTest(UnityEngine.Vector3, UnityEngine.RaycastHit ByRef, Single, UnityEngine.QueryTriggerInteraction)
static bool w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, float p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Contains(UnityEngine.Vector3, Boolean)
static bool w_bts_r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Vector4)
static bool w_bts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Overlaps(UnityEngine.Rect, Boolean)
static bool w_bts_r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Bounds)
static bool w_bts_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IntersectRay(UnityEngine.Ray, Single ByRef)
static bool w_bts_r4r4r4r4r4r4_Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, float* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(UnityEngine.Ray, UnityEngine.RaycastHit ByRef, Single)
static bool w_bts_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Matrix4x4)
static bool w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Char GetCharArrayElement(IntPtr, Int32)
static bool w_cpi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_cpi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef Il2CppChar (*FuncToCall)(void* p0, int32_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Char GetCharField(IntPtr, IntPtr)
static bool w_cpp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_cpp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef Il2CppChar (*FuncToCall)(void* p0, void* p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Char CallCharMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_cppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_cppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef Il2CppChar (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// SByte GetSByteArrayElement(IntPtr, Int32)
static bool w_i1pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i1pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int8_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// SByte GetSByteField(IntPtr, IntPtr)
static bool w_i1pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i1pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef int8_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// SByte CallSByteMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_i1ppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i1ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int8_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int16 GetShortArrayElement(IntPtr, Int32)
static bool w_i2pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i2pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int16_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int16 GetShortField(IntPtr, IntPtr)
static bool w_i2pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i2pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef int16_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int16 CallShortMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_i2ppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i2ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int16_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 get_pixelLightCount()
static bool w_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef int32_t (*FuncToCall)(const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Min(Int32[])
static bool w_i4Vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4Vi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal primitive params
    void* p0 = RestArguments<int32_t>::PackPrimitive(context, info, TIp0, 0);
                

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetGlobalInt(Int32)
static bool w_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UnityEngine.Experimental.Rendering.GraphicsFormat GetCompatibleFormat(UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.Experimental.Rendering.FormatUsage)
static bool w_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Clamp(Int32, Int32, Int32)
static bool w_i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetAllCameras(UnityEngine.Camera[])
static bool w_i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Throw(IntPtr)
static bool w_i4p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetIntArrayElement(IntPtr, Int32)
static bool w_i4pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetIntField(IntPtr, IntPtr)
static bool w_i4pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CallIntMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_i4ppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 ThrowNew(IntPtr, System.String)
static bool w_i4ps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CeilToInt(Single)
static bool w_i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(float p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 PropertyToID(System.String)
static bool w_i4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetRenderTextureSupportedMSAASampleCount(UnityEngine.RenderTextureDescriptor)
static bool w_i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef int32_t (*FuncToCall)(struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapSphereNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Collider[])
static bool w_i4s_r4r4r4_r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, float p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapSphereNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32)
static bool w_i4s_r4r4r4_r4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_r4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, float p1, void* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapSphereNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4_r4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_r4oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, float p1, void* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[])
static bool w_i4s_r4r4r4_r4s_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_r4s_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single)
static bool w_i4s_r4r4r4_r4s_r4r4r4_or4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_r4s_r4r4r4_or4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, void* p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32)
static bool w_i4s_r4r4r4_r4s_r4r4r4_or4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_r4s_r4r4r4_or4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, void* p3, float p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4_r4s_r4r4r4_or4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_r4s_r4r4r4_or4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, void* p3, float p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[])
static bool w_i4s_r4r4r4_s_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single)
static bool w_i4s_r4r4r4_s_r4r4r4_or4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_or4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, void* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32)
static bool w_i4s_r4r4r4_s_r4r4r4_or4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_or4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, void* p2, float p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4_s_r4r4r4_or4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_or4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, void* p2, float p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapBoxNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion)
static bool w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, void* p2, struct s_r4r4r4r4_ p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapBoxNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion, Int32)
static bool w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, void* p2, struct s_r4r4r4r4_ p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapBoxNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Collider[], UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, void* p2, struct s_r4r4r4r4_ p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[])
static bool w_i4s_r4r4r4_s_r4r4r4_r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32)
static bool w_i4s_r4r4r4_s_r4r4r4_r4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_r4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, void* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 OverlapCapsuleNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Collider[], Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4_s_r4r4r4_r4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_r4oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, void* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[])
static bool w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single)
static bool w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, void* p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32)
static bool w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, void* p4, float p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CapsuleCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, void* p4, float p5, int32_t p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[])
static bool w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion)
static bool w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, void* p3, struct s_r4r4r4r4_ p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single)
static bool w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, void* p3, struct s_r4r4r4r4_ p4, float p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single, Int32)
static bool w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, void* p3, struct s_r4r4r4r4_ p4, float p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BoxCastNonAlloc(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.RaycastHit[], UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, void* p3, struct s_r4r4r4r4_ p4, float p5, int32_t p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[])
static bool w_i4s_r4r4r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[], Single)
static bool w_i4s_r4r4r4r4r4r4_or4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_or4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, void* p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[], Single, Int32)
static bool w_i4s_r4r4r4r4r4r4_or4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_or4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, void* p1, float p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 RaycastNonAlloc(UnityEngine.Ray, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4r4r4r4_or4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_or4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, void* p1, float p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[])
static bool w_i4s_r4r4r4r4r4r4_r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[], Single)
static bool w_i4s_r4r4r4r4r4r4_r4or4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_r4or4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, void* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[], Single, Int32)
static bool w_i4s_r4r4r4r4r4r4_r4or4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_r4or4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, void* p2, float p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SphereCastNonAlloc(UnityEngine.Ray, Single, UnityEngine.RaycastHit[], Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_i4s_r4r4r4r4r4r4_r4or4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_r4r4r4r4r4r4_r4or4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef int32_t (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, void* p2, float p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UnityEngine.LightType get_type()
static bool w_i4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetTrails(Trails ByRef)
static bool w_i4tPs_ooooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tPs_ooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_ooooi4i4_* p0 = nullptr; // valuetype ref
    s_ooooi4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_ooooi4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef int32_t (*FuncToCall)(void*,struct s_ooooi4i4_* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetVertexAttributeDimension(UnityEngine.Rendering.VertexAttribute)
static bool w_i4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 MoveKey(Int32, UnityEngine.Keyframe)
static bool w_i4ti4s_r4r4r4r4i4i4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4s_r4r4r4r4i4i4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4i4i4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4i4i4r4r4_>(context, info[1]);
    s_r4r4r4r4i4i4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4i4i4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4i4i4r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetVertexAttributes(UnityEngine.Rendering.VertexAttributeDescriptor[])
static bool w_i4to(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4to");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Particle[], Int32)
static bool w_i4toi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Particle[], Int32, Int32)
static bool w_i4toi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AddKey(Single, Single)
static bool w_i4tr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,float p0, float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetBlendShapeIndex(System.String)
static bool w_i4ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle])
static bool w_i4ts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32)
static bool w_i4ts_Pvi4i4i4pi4i4oi4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32)
static bool w_i4ts_Pvi4i4i4pi4i4oi4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AddKey(UnityEngine.Keyframe)
static bool w_i4ts_r4r4r4r4i4i4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_r4r4r4r4i4i4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4i4i4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4i4i4r4r4_>(context, info[0]);
    s_r4r4r4r4i4i4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4i4i4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_r4r4r4r4i4i4r4r4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int64 get_maxGraphicsBufferSize()
static bool w_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef int64_t (*FuncToCall)(const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 GetLongArrayElement(IntPtr, Int32)
static bool w_i8pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int64_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 GetLongField(IntPtr, IntPtr)
static bool w_i8pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef int64_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 CallLongMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_i8ppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int64_t (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 get_dataSize()
static bool w_i8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int64_t (*FuncToCall)(void*,const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// UnityEngine.ILogger get_unityLogger()
static bool w_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_o");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AsyncOperation MoveMainWindowTo(UnityEngine.DisplayInfo ByRef, UnityEngine.Vector2Int)
static bool w_oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal Pstruct
    s_u8i4i4u4u4i4i4i4i4s_* p0 = nullptr; // valuetype ref
    s_u8i4i4u4u4i4i4i4i4s_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_u8i4i4u4u4i4i4i4i4s_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef void* (*FuncToCall)(struct s_u8i4i4u4u4i4i4i4i4s_* p0, struct s_i4i4_ p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Texture GetGlobalTexture(Int32)
static bool w_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Light[] GetLights(UnityEngine.LightType, Int32)
static bool w_oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsOfTypeAll(System.Type)
static bool w_oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsOfType(System.Type, Boolean)
static bool w_oob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsSortMode)
static bool w_ooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsInactive, UnityEngine.FindObjectsSortMode)
static bool w_ooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform)
static bool w_ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform, Boolean)
static bool w_ooob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Post(System.Uri, System.Collections.Generic.List`1[UnityEngine.Networking.IMultipartFormSection], Byte[])
static bool w_oooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object GetBuiltinResource(System.Type, System.String)
static bool w_oos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_oos_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Transform)
static bool w_oos_r4r4r4_s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Boolean[] FromBooleanArray(IntPtr)
static bool w_op(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_op");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AnimationCurve Constant(Single, Single, Single)
static bool w_or4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(float p0, float p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AnimationCurve Linear(Single, Single, Single, Single)
static bool w_or4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Shader Find(System.String)
static bool w_os(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Collider[] OverlapSphere(UnityEngine.Vector3, Single)
static bool w_os_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Collider[] OverlapSphere(UnityEngine.Vector3, Single, Int32)
static bool w_os_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Collider[] OverlapSphere(UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, int32_t p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3)
static bool w_os_r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3, Single)
static bool w_os_r4r4r4_r4s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, float p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32)
static bool w_os_r4r4r4_r4s_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4s_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, float p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4_r4s_r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4s_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, struct s_r4r4r4_ p2, float p3, int32_t p4, int32_t p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_os_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_os_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32)
static bool w_os_r4r4r4_s_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4_s_r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3)
static bool w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single)
static bool w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, float p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32)
static bool w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, float p4, int32_t p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] CapsuleCastAll(UnityEngine.Vector3, UnityEngine.Vector3, Single, UnityEngine.Vector3, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, struct s_r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, int32_t p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] BoxCastAll(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, int32_t p5, int32_t p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Collider[] OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Collider[] OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Collider[] OverlapBox(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Quaternion, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray)
static bool w_os_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray, Single)
static bool w_os_r4r4r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray, Single, Int32)
static bool w_os_r4r4r4r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] RaycastAll(UnityEngine.Ray, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4r4r4r4_r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4_r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, int32_t p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Ray, Single, Single)
static bool w_os_r4r4r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Ray, Single, Single, Int32)
static bool w_os_r4r4r4r4r4r4_r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4_r4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, float p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SphereCastAll(UnityEngine.Ray, Single, Single, Int32, UnityEngine.QueryTriggerInteraction)
static bool w_os_r4r4r4r4r4r4_r4r4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4_r4r4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, float p1, float p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AudioClip Create(System.String, Int32, Int32, Int32, Boolean)
static bool w_osi4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AudioClip Create(System.String, Int32, Int32, Int32, Boolean, PCMReaderCallback)
static bool w_osi4i4i4bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4i4i4bo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, bool p4, void* p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AudioClip Create(System.String, Int32, Int32, Int32, Boolean, PCMReaderCallback, PCMSetPositionCallback)
static bool w_osi4i4i4boo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4i4i4boo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, bool p4, void* p5, void* p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Load(System.String, System.Type)
static bool w_oso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Post(System.String, System.Collections.Generic.List`1[UnityEngine.Networking.IMultipartFormSection], Byte[])
static bool w_osoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Networking.UnityWebRequest Put(System.String, System.String)
static bool w_oss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Flare get_flare()
static bool w_ot(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ot");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Rendering.CommandBuffer[] GetCommandBuffers(UnityEngine.Rendering.LightEvent)
static bool w_oti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Int32[] GetTriangles(Int32, Boolean)
static bool w_oti4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.StateMachineBehaviour[] GetBehaviours(Int32, Int32)
static bool w_oti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Component GetComponent(System.Type)
static bool w_oto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Component GetComponentInChildren(System.Type, Boolean)
static bool w_otob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Shader GetDependency(System.String)
static bool w_ots(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Coroutine StartCoroutine(System.String, System.Object)
static bool w_otsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SweepTestAll(UnityEngine.Vector3)
static bool w_ots_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void* (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SweepTestAll(UnityEngine.Vector3, Single)
static bool w_ots_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RaycastHit[] SweepTestAll(UnityEngine.Vector3, Single, UnityEngine.QueryTriggerInteraction)
static bool w_ots_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4r4_r4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// IntPtr ExceptionOccurred()
static bool w_p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_p");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewBooleanArray(Int32)
static bool w_pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pi4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewObjectArray(Int32, IntPtr, IntPtr)
static bool w_pi4pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pi4pp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void* (*FuncToCall)(int32_t p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewString(Char[])
static bool w_po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_po");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr ToObjectArray(IntPtr[], IntPtr)
static bool w_pop(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pop");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr FromReflectedMethod(IntPtr)
static bool w_pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetObjectArrayElement(IntPtr, Int32)
static bool w_ppi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetConstructorID(IntPtr, System.Object[])
static bool w_ppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetObjectField(IntPtr, IntPtr)
static bool w_ppp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr ToReflectedMethod(IntPtr, IntPtr, Boolean)
static bool w_pppb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pppb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewObject(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_pppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pppo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetConstructorID(IntPtr, System.String)
static bool w_pps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pps");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetMethodID(IntPtr, System.String, System.Object[], Boolean)
static bool w_ppsob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppsob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetMethodID(IntPtr, System.String, System.String)
static bool w_ppss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetMethodID(IntPtr, System.String, System.String, Boolean)
static bool w_ppssb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppssb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr FindClass(System.String)
static bool w_ps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ps");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetNativeIndexBufferPtr()
static bool w_pt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pt");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetNativeVertexBufferPtr(Int32)
static bool w_pti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// Single get_time()
static bool w_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef float (*FuncToCall)(const void* method);
    float ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Min(Single[])
static bool w_r4Vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4Vr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal primitive params
    void* p0 = RestArguments<float>::PackPrimitive(context, info, TIp0, 0);
                

    typedef float (*FuncToCall)(void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetGlobalFloat(Int32)
static bool w_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetFloatArrayElement(IntPtr, Int32)
static bool w_r4pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(void* p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetFloatField(IntPtr, IntPtr)
static bool w_r4pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef float (*FuncToCall)(void* p0, void* p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single CallFloatMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_r4ppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef float (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GammaToLinearSpace(Single)
static bool w_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(float p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single PerlinNoise(Single, Single)
static bool w_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(float p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single)
static bool w_r4r4r4Pr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4Pr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single, Single)
static bool w_r4r4r4Pr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4Pr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single, Single, Single)
static bool w_r4r4r4Pr4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4Pr4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Clamp(Single, Single, Single)
static bool w_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef float (*FuncToCall)(float p0, float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetGlobalFloat(System.String)
static bool w_r4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef float (*FuncToCall)(void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SqrMagnitude(UnityEngine.Vector2)
static bool w_r4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_r4s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Magnitude(UnityEngine.Vector3)
static bool w_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SignedAngle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Magnitude(UnityEngine.Vector4)
static bool w_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector4, UnityEngine.Vector4)
static bool w_r4s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Determinant(UnityEngine.Matrix4x4)
static bool w_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single get_spotAngle()
static bool w_r4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single get_Item(Int32)
static bool w_r4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(void*,int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetBlendShapeFrameWeight(Int32, Int32)
static bool w_r4ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Evaluate(Single)
static bool w_r4tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4tr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(void*,float p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetFloat(System.String)
static bool w_r4ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef float (*FuncToCall)(void*,void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SqrDistance(UnityEngine.Vector3)
static bool w_r4ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single HalfToFloat(UInt16)
static bool w_r4u2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4u2");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(uint16_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double get_timeAsDouble()
static bool w_r8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double GetDoubleArrayElement(IntPtr, Int32)
static bool w_r8pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef double (*FuncToCall)(void* p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double GetDoubleField(IntPtr, IntPtr)
static bool w_r8pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8pp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef double (*FuncToCall)(void* p0, void* p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double CallDoubleMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_r8ppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8ppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef double (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// System.String get_globalRenderPipeline()
static bool w_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetSignature(System.Object)
static bool w_sO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// MeshDataArray AllocateWritableMeshData(Int32)
static bool w_s_Ppi4i4i4pi4i4o_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Ppi4i4i4pi4i4o_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_Ppi4i4i4pi4i4o_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_Ppi4i4i4pi4i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MeshDataArray AcquireReadOnlyMeshData(UnityEngine.Mesh)
static bool w_s_Ppi4i4i4pi4i4o_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Ppi4i4i4pi4i4o_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_Ppi4i4i4pi4i4o_ (*FuncToCall)(void* p0, const void* method);
    struct s_Ppi4i4i4pi4i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Unity.Collections.NativeArray`1[UnityEngine.BoneWeight1] GetAllBoneWeights()
static bool w_s_Pvi4i4i4pi4i4oi4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Pvi4i4i4pi4i4oi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_Pvi4i4i4pi4i4oi4_ (*FuncToCall)(void*,const void* method);
    struct s_Pvi4i4i4pi4i4oi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.PhysicsScene get_defaultPhysicsScene()
static bool w_s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4_ (*FuncToCall)(const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.LayerMask get_blockingMask()
static bool w_s_i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, Int32, UnityEngine.Rendering.ShaderTagId)
static bool w_s_i4_ti4i4s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_ti4i4s_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_i4_* pp2 = DataTransfer::GetPointer<s_i4_>(context, info[2]);
    s_i4_ p2 = pp2 ? *pp2 : s_i4_ {};

    typedef struct s_i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, struct s_i4_ p2, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, UnityEngine.Rendering.ShaderTagId)
static bool w_s_i4_ti4s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_ti4s_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef struct s_i4_ (*FuncToCall)(void*,int32_t p0, struct s_i4_ p1, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int get_mainWindowPosition()
static bool w_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4i4_ (*FuncToCall)(const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Resolution get_currentResolution()
static bool w_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4i4i4_ (*FuncToCall)(const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.AnimatorTransitionInfo GetAnimatorTransitionInfo(Int32)
static bool w_s_i4i4i4br4r4bi4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4br4r4bi4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4i4i4br4r4bi4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_i4i4i4br4r4bi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.VertexAttributeDescriptor GetVertexAttribute(Int32)
static bool w_s_i4i4i4i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.LightBakingOutput get_bakingOutput()
static bool w_s_i4i4i4i4b_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4i4b_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.AnimatorStateInfo GetCurrentAnimatorStateInfo(Int32)
static bool w_s_i4i4i4r4r4r4r4i4i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4r4r4r4r4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4i4i4r4r4r4r4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_i4i4i4r4r4r4r4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MinMaxGradient get_startColor()
static bool w_s_i4oor4r4r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4oor4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4oor4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_i4oor4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MinMaxCurve get_startDelay()
static bool w_s_i4r4oor4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4r4oor4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4r4oor4r4_ (*FuncToCall)(void*,const void* method);
    struct s_i4r4oor4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Touch GetTouch(Int32)
static bool w_s_i4r4r4r4r4r4r4r4i4i4i4r4r4r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4r4r4r4r4r4r4r4i4i4i4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4r4r4r4r4r4r4r4i4i4i4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_i4r4r4r4r4r4r4r4i4i4i4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MainModule get_main()
static bool w_s_o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_o_ (*FuncToCall)(void*,const void* method);
    struct s_o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Trails GetTrails()
static bool w_s_ooooi4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ooooi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_ooooi4i4_ (*FuncToCall)(void*,const void* method);
    struct s_ooooi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.TextGenerationSettings GetGenerationSettings(UnityEngine.Vector2)
static bool w_s_or4r4r4r4i4r4br4i4i4bbi4i4bi4i4r4r4r4r4b_ts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_or4r4r4r4i4r4br4i4i4bbi4i4bi4i4r4r4r4r4b_ts_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_or4r4r4r4i4r4br4i4i4bbi4i4bi4i4r4r4r4r4b_ (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    struct s_or4r4r4r4i4r4br4i4i4bbi4i4bi4i4r4r4r4r4b_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.LocalKeywordSpace get_keywordSpace()
static bool w_s_p_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_p_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_p_ (*FuncToCall)(void*,const void* method);
    struct s_p_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.PlayableGraph get_playableGraph()
static bool w_s_pu4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_pu4_ (*FuncToCall)(void*,const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 get_zero()
static bool w_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetTextAnchorPivot(UnityEngine.TextAnchor)
static bool w_s_r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Multiply(Single, UnityEngine.Vector2)
static bool w_s_r4r4_r4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_r4s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(float p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Perpendicular(UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 ClampMagnitude(UnityEngine.Vector2, Single)
static bool w_s_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, float p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Scale(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, float p4, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Lerp(UnityEngine.Vector2, UnityEngine.Vector2, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, float p2, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector3)
static bool w_s_r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector4)
static bool w_s_r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 NormalizedToPoint(UnityEngine.Rect, UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 get_areaSize()
static bool w_s_r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetPropertyRangeLimits(Int32)
static bool w_s_r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetTextureOffset(System.String)
static bool w_s_r4r4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_zero()
static bool w_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Multiply(Single, UnityEngine.Vector3)
static bool w_s_r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector2)
static bool w_s_r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Normalize(UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ClosestPoint(UnityEngine.Vector3, UnityEngine.Collider, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_s_r4r4r4_s_r4r4r4_os_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_os_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, void* p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ClampMagnitude(UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Scale(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Slerp(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 RotateTowards(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector4)
static bool w_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Multiply(UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_normalized()
static bool w_s_r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 GetIKPosition(UnityEngine.AvatarIKGoal)
static bool w_s_r4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 GetPoint(Single)
static bool w_s_r4r4r4_tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 TransformDirection(Single, Single, Single)
static bool w_s_r4r4r4_tr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ClosestPoint(UnityEngine.Vector3)
static bool w_s_r4r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3, MonoOrStereoscopicEye)
static bool w_s_r4r4r4_ts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// PlaybackState GetPlaybackState()
static bool w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 get_zero()
static bool w_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 GetGlobalVector(Int32)
static bool w_s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color CorrelatedColorTemperatureToRGB(Single)
static bool w_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion Euler(Single, Single, Single)
static bool w_s_r4r4r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color HSVToRGB(Single, Single, Single, Boolean)
static bool w_s_r4r4r4r4_r4r4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, bool p3, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect MinMaxRect(Single, Single, Single, Single)
static bool w_s_r4r4r4r4_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion AngleAxis(Single, UnityEngine.Vector3)
static bool w_s_r4r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Multiply(Single, UnityEngine.Vector4)
static bool w_s_r4r4r4r4_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 GetGlobalVector(System.String)
static bool w_s_r4r4r4r4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector2)
static bool w_s_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector3)
static bool w_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion FromToRotation(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 Normalize(UnityEngine.Vector4)
static bool w_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Multiply(UnityEngine.Vector4, Single)
static bool w_s_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 Scale(UnityEngine.Vector4, UnityEngine.Vector4)
static bool w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 Lerp(UnityEngine.Vector4, UnityEngine.Vector4, Single)
static bool w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, float p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Vector4)
static bool w_s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color get_color()
static bool w_s_r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 GetPropertyDefaultVectorValue(Int32)
static bool w_s_r4r4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetColor(System.String)
static bool w_s_r4r4r4r4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Plane TransformPlane(UnityEngine.Plane)
static bool w_s_r4r4r4r4_ts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ts_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Keyframe get_Item(Int32)
static bool w_s_r4r4r4r4i4i4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4i4i4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4i4i4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4i4i4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Bounds get_bounds()
static bool w_s_r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3, MonoOrStereoscopicEye)
static bool w_s_r4r4r4r4r4r4_ts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_ts_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SubMeshDescriptor GetSubMesh(Int32)
static bool w_s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4r4r4i4i4i4i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4r4r4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.ContactPoint GetContact(Int32)
static bool w_s_r4r4r4r4r4r4i4i4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4i4i4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4r4r4i4i4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4r4r4i4i4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 get_zero()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetGlobalMatrix(Int32)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Perspective(Single, Single, Single, Single)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Ortho(Single, Single, Single, Single, Single, Single)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetGlobalMatrix(System.String)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void* p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Scale(UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 LookAt(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 TRS(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Rotate(UnityEngine.Quaternion)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Frustum(UnityEngine.FrustumPlanes)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Inverse(UnityEngine.Matrix4x4)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 get_shadowMatrixOverride()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetMatrix(Int32)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetMatrix(System.String)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 CalculateObliqueMatrix(UnityEngine.Vector4)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.DisplayInfo get_mainWindowDisplayInfo()
static bool w_s_u8i4i4u4u4i4i4i4i4s_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8i4i4u4u4i4i4i4i4s_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_u8i4i4u4u4i4i4i4i4s_ (*FuncToCall)(const void* method);
    struct s_u8i4i4u4u4i4i4i4i4s_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Hash128 get_imageContentsHash()
static bool w_s_u8u8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8u8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_u8u8_ (*FuncToCall)(void*,const void* method);
    struct s_u8u8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.String GetSignature(System.Object[])
static bool w_so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetStringChars(IntPtr)
static bool w_sp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetStringField(IntPtr, IntPtr)
static bool w_spp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_spp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String CallStringMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_sppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sppo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String EscapeURL(System.String)
static bool w_ss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String EscapeURL(System.String, System.Text.Encoding)
static bool w_sso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString()
static bool w_st(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_st");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetBlendShapeName(Int32)
static bool w_sti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.String)
static bool w_sts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ReadFile(System.String, System.String ByRef)
static bool w_stsPs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stsPs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Ps
    void* up1 = nullptr; // string ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        v8::String::Utf8Value tp1(isolate, op1->Get(context, 0).ToLocalChecked());
        up1 = CStringToCSharpString(*tp1);
    }
        

    typedef void* (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSAnyToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetTag(System.String, Boolean)
static bool w_stsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetTag(System.String, Boolean, System.String)
static bool w_stsbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stsbs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.String, System.IFormatProvider)
static bool w_stso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// UInt16 FloatToHalf(Single)
static bool w_u2r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u2r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef uint16_t (*FuncToCall)(float p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 get_renderingLayerMask()
static bool w_u4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 GetIndexStart(Int32)
static bool w_u4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef uint32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt64 get_totalTextureMemory()
static bool w_u8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef uint64_t (*FuncToCall)(const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// UInt64 get_sceneCullingMask()
static bool w_u8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// Void TestJSCall()
static bool w_v(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_v");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void (*FuncToCall)(const void* method);
    ((FuncToCall)methodPointer)(  method);

    
    return true;
}

// Void Log(System.Object)
static bool w_vO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Log(System.Object, UnityEngine.Object)
static bool w_vOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void CalculateProjectionMatrixFromPhysicalProperties(UnityEngine.Matrix4x4 ByRef, Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Single, GateFitParameters)
static bool w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 6) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (length > 6 && (!info[6]->IsObject() || !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal valuetype  with default
    s_i4r4_ p6 = OptionalParameter<s_i4r4_>::GetValueType(context, info, method, 6);
                

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, float p1, struct s_r4r4_ p2, struct s_r4r4_ p3, float p4, float p5, struct s_i4r4_ p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef)
static bool w_vPs_su4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct s_su4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean)
static bool w_vPs_su4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_su4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(struct s_su4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void set_developerConsoleVisible(Boolean)
static bool w_vb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(bool p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object)
static bool w_vbO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbO");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object, UnityEngine.Object)
static bool w_vbOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbOo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Assert(Boolean, UnityEngine.Object)
static bool w_vbo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, UnityEngine.Object, System.String, System.Object[])
static bool w_vbosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbosVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal ref params
    void* p3 = RestArguments<void*>::PackRef(context, info, TIp3, 3);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Assert(Boolean, System.String)
static bool w_vbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, System.String, System.Object[])
static bool w_vbsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbsVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Assert(Boolean, System.String, UnityEngine.Object)
static bool w_vbso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbso");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_pixelLightCount(Int32)
static bool w_vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(int32_t p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void BakeMesh(Int32, Boolean)
static bool w_vi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalInt(Int32, Int32)
static bool w_vi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetResolution(Int32, Int32, Boolean)
static bool w_vi4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetResolution(Int32, Int32, Boolean, Int32)
static bool w_vi4i4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode)
static bool w_vi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, Int32)
static bool w_vi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, UnityEngine.LogOption, UnityEngine.Object, System.String, System.Object[])
static bool w_vi4i4osVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4osVO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);
    // JSValToCSVal ref params
    void* p4 = RestArguments<void*>::PackRef(context, info, TIp4, 4);
                

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetGlobalTexture(Int32, UnityEngine.Texture)
static bool w_vi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalTexture(Int32, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetGlobalConstantBuffer(Int32, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vi4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(int32_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetGlobalFloat(Int32, Single)
static bool w_vi4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalVector(Int32, UnityEngine.Vector4)
static bool w_vi4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4s_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(int32_t p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalMatrix(Int32, UnityEngine.Matrix4x4)
static bool w_vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void UpdateCubeRotate(Puerts.ArrayBuffer)
static bool w_vo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    PLog(LogLevel::Log, "Running w_vo UpdateCubeRotate");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetUITookitEventSystemOverride(UnityEngine.EventSystems.EventSystem, Boolean, Boolean)
static bool w_voDbDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voDbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void* p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DestroyImmediate(UnityEngine.Object, Boolean)
static bool w_vob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void GetOutputData(Single[], Int32)
static bool w_voi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void GetSpectrumData(Single[], Int32, UnityEngine.FFTWindow)
static bool w_voi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void LogException(System.Exception, UnityEngine.Object)
static bool w_voo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void IgnoreCollision(UnityEngine.Collider, UnityEngine.Collider, Boolean)
static bool w_voob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AddUIVertexStream(System.Collections.Generic.List`1[UnityEngine.UIVertex], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Color32], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector4])
static bool w_vooooooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vooooooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void SplitUIVertexStreams(System.Collections.Generic.List`1[UnityEngine.UIVertex], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Color32], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[System.Int32])
static bool w_voooooooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voooooooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void AddUIVertexStream(System.Collections.Generic.List`1[UnityEngine.UIVertex], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Color32], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector4])
static bool w_vooooooooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vooooooooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void SplitUIVertexStreams(System.Collections.Generic.List`1[UnityEngine.UIVertex], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Color32], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector4], System.Collections.Generic.List`1[System.Int32])
static bool w_voooooooooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voooooooooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp7 = wrapData->TypeInfos[7];
    auto TIp8 = wrapData->TypeInfos[8];
    auto TIp9 = wrapData->TypeInfos[9];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void Destroy(UnityEngine.Object, Single)
static bool w_vor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.Object, System.String, System.Object[])
static bool w_vosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vosVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DeleteGlobalRef(IntPtr)
static bool w_vp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vp");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetBooleanArrayElement(IntPtr, Int32, Boolean)
static bool w_vpi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetCharArrayElement(IntPtr, Int32, Char)
static bool w_vpi4c(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4c");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, Il2CppChar p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetSByteArrayElement(IntPtr, Int32, SByte)
static bool w_vpi4i1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i1");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int8_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int8_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetShortArrayElement(IntPtr, Int32, Int16)
static bool w_vpi4i2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i2");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int16_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int16_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetIntArrayElement(IntPtr, Int32, Int32)
static bool w_vpi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetLongArrayElement(IntPtr, Int32, Int64)
static bool w_vpi4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetObjectArrayElement(IntPtr, Int32, IntPtr)
static bool w_vpi4p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetFloatArrayElement(IntPtr, Int32, Single)
static bool w_vpi4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetDoubleArrayElement(IntPtr, Int32, Double)
static bool w_vpi4r8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4r8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<double>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, double p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetBooleanField(IntPtr, IntPtr, Boolean)
static bool w_vppb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetCharField(IntPtr, IntPtr, Char)
static bool w_vppc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppc");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, Il2CppChar p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetSByteField(IntPtr, IntPtr, SByte)
static bool w_vppi1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppi1");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<int8_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int8_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetShortField(IntPtr, IntPtr, Int16)
static bool w_vppi2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppi2");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<int16_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    int16_t p2 = converter::Converter<int16_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int16_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetIntField(IntPtr, IntPtr, Int32)
static bool w_vppi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetLongField(IntPtr, IntPtr, Int64)
static bool w_vppi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void CallVoidMethod(IntPtr, IntPtr, UnityEngine.jvalue[])
static bool w_vppo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetObjectField(IntPtr, IntPtr, IntPtr)
static bool w_vppp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetFloatField(IntPtr, IntPtr, Single)
static bool w_vppr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetDoubleField(IntPtr, IntPtr, Double)
static bool w_vppr8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppr8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<double>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    double p2 = converter::Converter<double>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, double p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetStringField(IntPtr, IntPtr, System.String)
static bool w_vpps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_fixedDeltaTime(Single)
static bool w_vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(float p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void set_globalRenderPipeline(System.String)
static bool w_vs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void LogFormat(System.String, System.Object[])
static bool w_vsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void ApplyAndDisposeWritableMeshData(MeshDataArray, UnityEngine.Mesh, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vs_Ppi4i4i4pi4i4o_oDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_Ppi4i4i4pi4i4o_oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_Ppi4i4i4pi4i4o_* pp0 = DataTransfer::GetPointer<s_Ppi4i4i4pi4i4o_>(context, info[0]);
    s_Ppi4i4i4pi4i4o_ p0 = pp0 ? *pp0 : s_Ppi4i4i4pi4i4o_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(struct s_Ppi4i4i4pi4i4o_ p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void InstanceIDToObjectList(Unity.Collections.NativeArray`1[System.Int32], System.Collections.Generic.List`1[UnityEngine.Object])
static bool w_vs_Pvi4i4i4pi4i4oi4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_Pvi4i4i4pi4i4oi4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(struct s_Pvi4i4i4pi4i4oi4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void set_compositionCursorPos(UnityEngine.Vector2)
static bool w_vs_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void set_gravity(UnityEngine.Vector3)
static bool w_vs_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single, Boolean)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void RGBToHSV(UnityEngine.Color, Single ByRef, Single ByRef, Single ByRef)
static bool w_vs_r4r4r4r4_Pr4Pr4Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_Pr4Pr4Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[3]);
    float* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, float* p1, float* p2, float* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<float>::toScript(context, *p3));
    }
    
    return true;
}

// Void RebuildBroadphaseRegions(UnityEngine.Bounds, Int32)
static bool w_vs_r4r4r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalInt(System.String, Int32)
static bool w_vsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalTexture(System.String, UnityEngine.Texture)
static bool w_vso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalTexture(System.String, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vsoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetGlobalConstantBuffer(System.String, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vsoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetGlobalFloat(System.String, Single)
static bool w_vsr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalVector(System.String, UnityEngine.Vector4)
static bool w_vss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalMatrix(System.String, UnityEngine.Matrix4x4)
static bool w_vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Reset()
static bool w_vt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void (*FuncToCall)(void*,const void* method);
    ((FuncToCall)methodPointer)(self,  method);

    
    return true;
}

// Void RecalculateUVDistributionMetrics(Single)
static bool w_vtDr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,float p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ToAngleAxis(Single ByRef, UnityEngine.Vector3 ByRef)
static bool w_vtPr4Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPr4Ps_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[0]);
    float* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,float* p0, struct s_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<float>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void EnableKeyword(UnityEngine.Rendering.LocalKeyword ByRef)
static bool w_vtPs_psu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_psu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_psu4_* p0 = nullptr; // valuetype ref
    s_psu4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_psu4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_psu4_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void SetKeyword(UnityEngine.Rendering.LocalKeyword ByRef, Boolean)
static bool w_vtPs_psu4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_psu4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_psu4_* p0 = nullptr; // valuetype ref
    s_psu4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_psu4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_psu4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void GetPositionAndRotation(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef)
static bool w_vtPs_r4r4r4_Ps_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4_Ps_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_* p0, struct s_r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void .ctor(UnityEngine.Keyframe[])
static bool w_vtVs_r4r4r4r4i4i4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVs_r4r4r4r4i4i4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal valuetype params
    void* p0 = RestArguments<s_r4r4r4r4i4i4r4r4_>::PackValueType(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_useColorTemperature(Boolean)
static bool w_vtb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,bool p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Stop(Boolean, UnityEngine.ParticleSystemStopBehavior)
static bool w_vtbi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_type(UnityEngine.LightType)
static bool w_vti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void RecalculateUVDistributionMetric(Int32, Single)
static bool w_vti4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void TriggerSubEmitter(Int32, Particle ByRef)
static bool w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void SetVertexBufferParams(Int32, UnityEngine.Rendering.VertexAttributeDescriptor[])
static bool w_vti4Vs_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Vs_i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal valuetype params
    void* p1 = RestArguments<s_i4i4i4i4_>::PackValueType(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetDirection(Direction, Boolean)
static bool w_vti4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetIndexBufferParams(Int32, UnityEngine.Rendering.IndexFormat)
static bool w_vti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(RenderRequestMode, RenderRequestOutputSpace, UnityEngine.RenderTexture)
static bool w_vti4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetBlendShapeFrameVertices(Int32, Int32, UnityEngine.Vector3[], UnityEngine.Vector3[], UnityEngine.Vector3[])
static bool w_vti4i4ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4ooo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void set_Item(Int32, Int32, Single)
static bool w_vti4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddCommandBuffer(UnityEngine.Rendering.LightEvent, UnityEngine.Rendering.CommandBuffer)
static bool w_vti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddCommandBuffer(UnityEngine.Rendering.LightEvent, UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.ShadowMapPass)
static bool w_vti4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddCommandBufferAsync(UnityEngine.Rendering.LightEvent, UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.ShadowMapPass, UnityEngine.Rendering.ComputeQueueType)
static bool w_vti4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetUVs(Int32, System.Collections.Generic.List`1[UnityEngine.Vector2], Int32, Int32, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vti4oi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4oi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void set_Item(Int32, Single)
static bool w_vti4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(Int32, Single, Int32)
static bool w_vti4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(Int32, Single, Int32, Single)
static bool w_vti4r4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(Int32, Single, Int32, Single, Single)
static bool w_vti4r4i4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4i4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetInsetAndSizeFromParentEdge(Edge, Single, Single)
static bool w_vti4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetFloat(Int32, Single, Single, Single)
static bool w_vti4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetVertexBufferParams(Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.VertexAttributeDescriptor])
static bool w_vti4s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_Pvi4i4i4pi4i4oi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTextureOffset(Int32, UnityEngine.Vector2)
static bool w_vti4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetIKPosition(UnityEngine.AvatarIKGoal, UnityEngine.Vector3)
static bool w_vti4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetColor(Int32, UnityEngine.Color)
static bool w_vti4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSubMesh(Int32, UnityEngine.Rendering.SubMeshDescriptor, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4i4i4i4i4i4i4_>(context, info[1]);
    s_r4r4r4r4r4r4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4i4i4i4i4i4i4_ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4i4i4i4i4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetMatrix(Int32, UnityEngine.Matrix4x4)
static bool w_vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_flare(UnityEngine.Flare)
static bool w_vto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void BakeMesh(UnityEngine.Mesh, Boolean)
static bool w_vtoDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSubMeshes(UnityEngine.Rendering.SubMeshDescriptor[], UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vtoDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CombineMeshes(UnityEngine.CombineInstance[], Boolean)
static bool w_vtob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CombineMeshes(UnityEngine.CombineInstance[], Boolean, Boolean)
static bool w_vtobb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CombineMeshes(UnityEngine.CombineInstance[], Boolean, Boolean, Boolean)
static bool w_vtobbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobbb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetMaterial(UnityEngine.Material, Int32)
static bool w_vtoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetTriangles(System.Collections.Generic.List`1[System.UInt16], Int32, Boolean)
static bool w_vtoi4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTriangles(UInt16[], Int32, Boolean, Int32)
static bool w_vtoi4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void GetTriangles(System.Collections.Generic.List`1[System.Int32], Int32, Boolean)
static bool w_vtoi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTriangles(Int32[], Int32, Boolean, Int32)
static bool w_vtoi4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4bi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetVertices(System.Collections.Generic.List`1[UnityEngine.Vector3], Int32, Int32)
static bool w_vtoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetIndices(UInt16[], UnityEngine.MeshTopology, Int32, Boolean, Int32)
static bool w_vtoi4i4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, bool p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetSubMeshes(UnityEngine.Rendering.SubMeshDescriptor[], Int32, Int32, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vtoi4i4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetIndices(Int32[], UnityEngine.MeshTopology, Int32, Boolean)
static bool w_vtoi4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetIndices(Int32[], UnityEngine.MeshTopology, Int32, Boolean, Int32)
static bool w_vtoi4i4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4bi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, bool p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetVertices(System.Collections.Generic.List`1[UnityEngine.Vector3], Int32, Int32, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vtoi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTriangles(Int32[], Int32, Int32, Int32, Boolean, Int32)
static bool w_vtoi4i4i4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<bool>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, bool p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetIndices(Int32[], Int32, Int32, UnityEngine.MeshTopology, Int32, Boolean, Int32)
static bool w_vtoi4i4i4i4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4i4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<bool>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 6);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, bool p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void SetMaterial(UnityEngine.Material, UnityEngine.Texture)
static bool w_vtoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void BakeMesh(UnityEngine.Mesh, UnityEngine.Camera, Boolean)
static bool w_vtooDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooDb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Lerp(UnityEngine.Material, UnityEngine.Material, Single)
static bool w_vtoor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoor4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SampleAnimation(UnityEngine.GameObject, Single)
static bool w_vtor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetReplacementShader(UnityEngine.Shader, System.String)
static bool w_vtos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTargetBuffers(UnityEngine.RenderBuffer[], UnityEngine.RenderBuffer)
static bool w_vtos_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void LookAt(UnityEngine.Transform, UnityEngine.Vector3)
static bool w_vtos_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.Uri, System.String, UnityEngine.Networking.DownloadHandler, UnityEngine.Networking.UploadHandler)
static bool w_vtosoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_spotAngle(Single)
static bool w_vtr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,float p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Simulate(Single, Boolean)
static bool w_vtr4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Simulate(Single, Boolean, Boolean)
static bool w_vtr4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Simulate(Single, Boolean, Boolean, Boolean)
static bool w_vtr4bbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4bbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Set(Single, Single)
static bool w_vtr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Set(Single, Single, Single)
static bool w_vtr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Space)
static bool w_vtr4r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Transform)
static bool w_vtr4r4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Set(Single, Single, Single, Single)
static bool w_vtr4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetLookAtWeight(Single, Single, Single, Single, Single)
static bool w_vtr4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void AddExplosionForce(Single, UnityEngine.Vector3, Single)
static bool w_vtr4s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4_r4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddExplosionForce(Single, UnityEngine.Vector3, Single, Single)
static bool w_vtr4s_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4_ p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddExplosionForce(Single, UnityEngine.Vector3, Single, Single, UnityEngine.ForceMode)
static bool w_vtr4s_r4r4r4_r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4_r4r4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4_ p1, float p2, float p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void set_sortingLayerName(System.String)
static bool w_vts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, System.Object)
static bool w_vtsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, System.Object, UnityEngine.SendMessageOptions)
static bool w_vtsOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.String, System.Type[])
static bool w_vtsVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle])
static bool w_vts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32)
static bool w_vts_Pvi4i4i4pi4i4oi4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32)
static bool w_vts_Pvi4i4i4pi4i4oi4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetBoneWeights(Unity.Collections.NativeArray`1[System.Byte], Unity.Collections.NativeArray`1[UnityEngine.BoneWeight1])
static bool w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_blockingMask(UnityEngine.LayerMask)
static bool w_vts_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_bakingOutput(UnityEngine.LightBakingOutput)
static bool w_vts_i4i4i4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4b_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4b_>(context, info[0]);
    s_i4i4i4i4b_ p0 = pp0 ? *pp0 : s_i4i4i4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4i4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_startColor(MinMaxGradient)
static bool w_vts_i4oor4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4oor4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4oor4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_i4oor4r4r4r4r4r4r4r4_>(context, info[0]);
    s_i4oor4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_i4oor4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4oor4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTargetBuffers(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer)
static bool w_vts_i4p_s_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4p_s_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};

    typedef void (*FuncToCall)(void*,struct s_i4p_ p0, struct s_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_startDelay(MinMaxCurve)
static bool w_vts_i4r4oor4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4r4oor4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4r4oor4r4_* pp0 = DataTransfer::GetPointer<s_i4r4oor4r4_>(context, info[0]);
    s_i4r4oor4r4_ p0 = pp0 ? *pp0 : s_i4r4oor4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4r4oor4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTrails(Trails)
static bool w_vts_ooooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_ooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_ooooi4i4_* pp0 = DataTransfer::GetPointer<s_ooooi4i4_>(context, info[0]);
    s_ooooi4i4_ p0 = pp0 ? *pp0 : s_ooooi4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_ooooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_areaSize(UnityEngine.Vector2)
static bool w_vts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_vts_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Scale(UnityEngine.Vector3)
static bool w_vts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Space)
static bool w_vts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Transform)
static bool w_vts_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single, UnityEngine.Space)
static bool w_vts_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetLookRotation(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddForceAtPosition(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.ForceMode)
static bool w_vts_r4r4r4_s_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void RotateAround(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPositionAndRotation(UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_vts_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void MatchTarget(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.AvatarTarget, UnityEngine.MatchTargetWeightMask, Single)
static bool w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, int32_t p2, struct s_r4r4r4r4_ p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void MatchTarget(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.AvatarTarget, UnityEngine.MatchTargetWeightMask, Single, Single)
static bool w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, int32_t p2, struct s_r4r4r4r4_ p3, float p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void MatchTarget(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.AvatarTarget, UnityEngine.MatchTargetWeightMask, Single, Single, Boolean)
static bool w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, int32_t p2, struct s_r4r4r4r4_ p3, float p4, float p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void SetTRS(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPlaybackState(PlaybackState)
static bool w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_>(context, info[0]);
    s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_color(UnityEngine.Color)
static bool w_vts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void CalculateFrustumCorners(UnityEngine.Rect, Single, MonoOrStereoscopicEye, UnityEngine.Vector3[])
static bool w_vts_r4r4r4r4_r4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_r4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, float p1, int32_t p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4)
static bool w_vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_bounds(UnityEngine.Bounds)
static bool w_vts_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_shadowMatrixOverride(UnityEngine.Matrix4x4)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Emit(EmitParams, Int32)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_imageContentsHash(UnityEngine.Hash128)
static bool w_vts_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8u8_* pp0 = DataTransfer::GetPointer<s_u8u8_>(context, info[0]);
    s_u8u8_ p0 = pp0 ? *pp0 : s_u8u8_ {};

    typedef void (*FuncToCall)(void*,struct s_u8u8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetShaderPassEnabled(System.String, Boolean)
static bool w_vtsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetInt(System.String, Int32)
static bool w_vtsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void PlayInFixedTime(System.String, Int32, Single)
static bool w_vtsi4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTexture(System.String, UnityEngine.Texture)
static bool w_vtso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTexture(System.String, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vtsoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetConstantBuffer(System.String, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vtsoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetCurve(System.String, System.Type, System.String, UnityEngine.AnimationCurve)
static bool w_vtsoso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetFloat(System.String, Single)
static bool w_vtsr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(System.String, Single, Int32)
static bool w_vtsr4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(System.String, Single, Int32, Single)
static bool w_vtsr4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4i4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, int32_t p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CrossFadeInFixedTime(System.String, Single, Int32, Single, Single)
static bool w_vtsr4i4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4i4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, int32_t p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void AddBlendShapeFrame(System.String, Single, UnityEngine.Vector3[], UnityEngine.Vector3[], UnityEngine.Vector3[])
static bool w_vtsr4ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4ooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,void* p0, float p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void InvokeRepeating(System.String, Single, Single)
static bool w_vtsr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetFloat(System.String, Single, Single, Single)
static bool w_vtsr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetOverrideTag(System.String, System.String)
static bool w_vtss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTextureOffset(System.String, UnityEngine.Vector2)
static bool w_vtss_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetColor(System.String, UnityEngine.Color)
static bool w_vtss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetMatrix(System.String, UnityEngine.Matrix4x4)
static bool w_vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, System.String, UnityEngine.Networking.DownloadHandler, UnityEngine.Networking.UploadHandler)
static bool w_vtssoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtssoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_renderingLayerMask(UInt32)
static bool w_vtu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,uint32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_overrideSceneCullingMask(UInt64)
static bool w_vtu8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,uint64_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

static WrapFuncInfo g_wrapFuncInfos[] = {
    
    {"b", w_b},
    {"bPs_su4_", w_bPs_su4_},
    {"bi4", w_bi4},
    {"bi4i4", w_bi4i4},
    {"bo", w_bo},
    {"boo", w_boo},
    {"bos_r4r4r4_s_r4r4r4r4_os_r4r4r4_s_r4r4r4r4_Ps_r4r4r4_Pr4", w_bos_r4r4r4_s_r4r4r4r4_os_r4r4r4_s_r4r4r4r4_Ps_r4r4r4_Pr4},
    {"bpi4", w_bpi4},
    {"bpp", w_bpp},
    {"bppo", w_bppo},
    {"br4r4", w_br4r4},
    {"bs", w_bs},
    {"bs_i4_s_i4_", w_bs_i4_s_i4_},
    {"bs_r4r4_s_r4r4_", w_bs_r4r4_s_r4r4_},
    {"bs_r4r4r4_r4", w_bs_r4r4r4_r4},
    {"bs_r4r4r4_r4i4", w_bs_r4r4r4_r4i4},
    {"bs_r4r4r4_r4i4i4", w_bs_r4r4r4_r4i4i4},
    {"bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_", w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_},
    {"bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4", w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4},
    {"bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4", w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4},
    {"bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4", w_bs_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4},
    {"bs_r4r4r4_s_r4r4r4_", w_bs_r4r4r4_s_r4r4r4_},
    {"bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_", w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_},
    {"bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4", w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4},
    {"bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4i4", w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_i4i4},
    {"bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4", w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4},
    {"bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4", w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4},
    {"bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4", w_bs_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4},
    {"bs_r4r4r4_s_r4r4r4_i4", w_bs_r4r4r4_s_r4r4r4_i4},
    {"bs_r4r4r4_s_r4r4r4_i4i4", w_bs_r4r4r4_s_r4r4r4_i4i4},
    {"bs_r4r4r4_s_r4r4r4_r4", w_bs_r4r4r4_s_r4r4r4_r4},
    {"bs_r4r4r4_s_r4r4r4_r4i4", w_bs_r4r4r4_s_r4r4r4_r4i4},
    {"bs_r4r4r4_s_r4r4r4_r4i4i4", w_bs_r4r4r4_s_r4r4r4_r4i4i4},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4},
    {"bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4", w_bs_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4i4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_s_r4r4r4r4_r4i4i4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4},
    {"bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4", w_bs_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4},
    {"bs_r4r4r4r4_s_r4r4r4r4_", w_bs_r4r4r4r4_s_r4r4r4r4_},
    {"bs_r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_", w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_},
    {"bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4", w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4},
    {"bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4", w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4},
    {"bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4", w_bs_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4},
    {"bs_r4r4r4r4r4r4_r4", w_bs_r4r4r4r4r4r4_r4},
    {"bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_", w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_},
    {"bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4", w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4},
    {"bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4", w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4},
    {"bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4", w_bs_r4r4r4r4r4r4_r4Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4i4},
    {"bs_r4r4r4r4r4r4_r4i4", w_bs_r4r4r4r4r4r4_r4i4},
    {"bs_r4r4r4r4r4r4_r4i4i4", w_bs_r4r4r4r4r4r4_r4i4i4},
    {"bs_r4r4r4r4r4r4_r4r4", w_bs_r4r4r4r4r4r4_r4r4},
    {"bs_r4r4r4r4r4r4_r4r4i4", w_bs_r4r4r4r4r4r4_r4r4i4},
    {"bs_r4r4r4r4r4r4_r4r4i4i4", w_bs_r4r4r4r4r4r4_r4r4i4i4},
    {"bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bt", w_bt},
    {"btO", w_btO},
    {"btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_", w_btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_},
    {"btPs_psu4_", w_btPs_psu4_},
    {"btb", w_btb},
    {"btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_", w_btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_},
    {"bti4", w_bti4},
    {"bti4PsPi4", w_bti4PsPi4},
    {"bti4i4", w_bti4i4},
    {"bto", w_bto},
    {"btoPo", w_btoPo},
    {"btoi4", w_btoi4},
    {"btoi4i4", w_btoi4i4},
    {"bts", w_bts},
    {"bts_r4r4_", w_bts_r4r4_},
    {"bts_r4r4r4_", w_bts_r4r4r4_},
    {"bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_", w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_},
    {"bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4", w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4},
    {"bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4", w_bts_r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4i4},
    {"bts_r4r4r4_b", w_bts_r4r4r4_b},
    {"bts_r4r4r4r4_", w_bts_r4r4r4r4_},
    {"bts_r4r4r4r4_b", w_bts_r4r4r4r4_b},
    {"bts_r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4_},
    {"bts_r4r4r4r4r4r4_Pr4", w_bts_r4r4r4r4r4r4_Pr4},
    {"bts_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4", w_bts_r4r4r4r4r4r4_Ps_r4r4r4r4r4r4u4r4r4r4i4_r4},
    {"bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"cpi4", w_cpi4},
    {"cpp", w_cpp},
    {"cppo", w_cppo},
    {"i1pi4", w_i1pi4},
    {"i1pp", w_i1pp},
    {"i1ppo", w_i1ppo},
    {"i2pi4", w_i2pi4},
    {"i2pp", w_i2pp},
    {"i2ppo", w_i2ppo},
    {"i4", w_i4},
    {"i4Vi4", w_i4Vi4},
    {"i4i4", w_i4i4},
    {"i4i4i4", w_i4i4i4},
    {"i4i4i4i4", w_i4i4i4i4},
    {"i4o", w_i4o},
    {"i4p", w_i4p},
    {"i4pi4", w_i4pi4},
    {"i4pp", w_i4pp},
    {"i4ppo", w_i4ppo},
    {"i4ps", w_i4ps},
    {"i4r4", w_i4r4},
    {"i4s", w_i4s},
    {"i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_", w_i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_},
    {"i4s_r4r4r4_r4o", w_i4s_r4r4r4_r4o},
    {"i4s_r4r4r4_r4oi4", w_i4s_r4r4r4_r4oi4},
    {"i4s_r4r4r4_r4oi4i4", w_i4s_r4r4r4_r4oi4i4},
    {"i4s_r4r4r4_r4s_r4r4r4_o", w_i4s_r4r4r4_r4s_r4r4r4_o},
    {"i4s_r4r4r4_r4s_r4r4r4_or4", w_i4s_r4r4r4_r4s_r4r4r4_or4},
    {"i4s_r4r4r4_r4s_r4r4r4_or4i4", w_i4s_r4r4r4_r4s_r4r4r4_or4i4},
    {"i4s_r4r4r4_r4s_r4r4r4_or4i4i4", w_i4s_r4r4r4_r4s_r4r4r4_or4i4i4},
    {"i4s_r4r4r4_s_r4r4r4_o", w_i4s_r4r4r4_s_r4r4r4_o},
    {"i4s_r4r4r4_s_r4r4r4_or4", w_i4s_r4r4r4_s_r4r4r4_or4},
    {"i4s_r4r4r4_s_r4r4r4_or4i4", w_i4s_r4r4r4_s_r4r4r4_or4i4},
    {"i4s_r4r4r4_s_r4r4r4_or4i4i4", w_i4s_r4r4r4_s_r4r4r4_or4i4i4},
    {"i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_", w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_},
    {"i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4", w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4},
    {"i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4i4", w_i4s_r4r4r4_s_r4r4r4_os_r4r4r4r4_i4i4},
    {"i4s_r4r4r4_s_r4r4r4_r4o", w_i4s_r4r4r4_s_r4r4r4_r4o},
    {"i4s_r4r4r4_s_r4r4r4_r4oi4", w_i4s_r4r4r4_s_r4r4r4_r4oi4},
    {"i4s_r4r4r4_s_r4r4r4_r4oi4i4", w_i4s_r4r4r4_s_r4r4r4_r4oi4i4},
    {"i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_o", w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_o},
    {"i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4", w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4},
    {"i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4", w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4},
    {"i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4i4", w_i4s_r4r4r4_s_r4r4r4_r4s_r4r4r4_or4i4i4},
    {"i4s_r4r4r4_s_r4r4r4_s_r4r4r4_o", w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_o},
    {"i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_", w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_},
    {"i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4", w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4},
    {"i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4", w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4},
    {"i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4i4", w_i4s_r4r4r4_s_r4r4r4_s_r4r4r4_os_r4r4r4r4_r4i4i4},
    {"i4s_r4r4r4r4r4r4_o", w_i4s_r4r4r4r4r4r4_o},
    {"i4s_r4r4r4r4r4r4_or4", w_i4s_r4r4r4r4r4r4_or4},
    {"i4s_r4r4r4r4r4r4_or4i4", w_i4s_r4r4r4r4r4r4_or4i4},
    {"i4s_r4r4r4r4r4r4_or4i4i4", w_i4s_r4r4r4r4r4r4_or4i4i4},
    {"i4s_r4r4r4r4r4r4_r4o", w_i4s_r4r4r4r4r4r4_r4o},
    {"i4s_r4r4r4r4r4r4_r4or4", w_i4s_r4r4r4r4r4r4_r4or4},
    {"i4s_r4r4r4r4r4r4_r4or4i4", w_i4s_r4r4r4r4r4r4_r4or4i4},
    {"i4s_r4r4r4r4r4r4_r4or4i4i4", w_i4s_r4r4r4r4r4r4_r4or4i4i4},
    {"i4t", w_i4t},
    {"i4tPs_ooooi4i4_", w_i4tPs_ooooi4i4_},
    {"i4ti4", w_i4ti4},
    {"i4ti4s_r4r4r4r4i4i4r4r4_", w_i4ti4s_r4r4r4r4i4i4r4r4_},
    {"i4to", w_i4to},
    {"i4toi4", w_i4toi4},
    {"i4toi4i4", w_i4toi4i4},
    {"i4tr4r4", w_i4tr4r4},
    {"i4ts", w_i4ts},
    {"i4ts_Pvi4i4i4pi4i4oi4_", w_i4ts_Pvi4i4i4pi4i4oi4_},
    {"i4ts_Pvi4i4i4pi4i4oi4_i4", w_i4ts_Pvi4i4i4pi4i4oi4_i4},
    {"i4ts_Pvi4i4i4pi4i4oi4_i4i4", w_i4ts_Pvi4i4i4pi4i4oi4_i4i4},
    {"i4ts_r4r4r4r4i4i4r4r4_", w_i4ts_r4r4r4r4i4i4r4r4_},
    {"i8", w_i8},
    {"i8pi4", w_i8pi4},
    {"i8pp", w_i8pp},
    {"i8ppo", w_i8ppo},
    {"i8t", w_i8t},
    {"o", w_o},
    {"oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_", w_oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_},
    {"oi4", w_oi4},
    {"oi4i4", w_oi4i4},
    {"oo", w_oo},
    {"oob", w_oob},
    {"ooi4", w_ooi4},
    {"ooi4i4", w_ooi4i4},
    {"ooo", w_ooo},
    {"ooob", w_ooob},
    {"oooo", w_oooo},
    {"oos", w_oos},
    {"oos_r4r4r4_s_r4r4r4r4_", w_oos_r4r4r4_s_r4r4r4r4_},
    {"oos_r4r4r4_s_r4r4r4r4_o", w_oos_r4r4r4_s_r4r4r4r4_o},
    {"op", w_op},
    {"or4r4r4", w_or4r4r4},
    {"or4r4r4r4", w_or4r4r4r4},
    {"os", w_os},
    {"os_r4r4r4_r4", w_os_r4r4r4_r4},
    {"os_r4r4r4_r4i4", w_os_r4r4r4_r4i4},
    {"os_r4r4r4_r4i4i4", w_os_r4r4r4_r4i4i4},
    {"os_r4r4r4_r4s_r4r4r4_", w_os_r4r4r4_r4s_r4r4r4_},
    {"os_r4r4r4_r4s_r4r4r4_r4", w_os_r4r4r4_r4s_r4r4r4_r4},
    {"os_r4r4r4_r4s_r4r4r4_r4i4", w_os_r4r4r4_r4s_r4r4r4_r4i4},
    {"os_r4r4r4_r4s_r4r4r4_r4i4i4", w_os_r4r4r4_r4s_r4r4r4_r4i4i4},
    {"os_r4r4r4_s_r4r4r4_", w_os_r4r4r4_s_r4r4r4_},
    {"os_r4r4r4_s_r4r4r4_r4", w_os_r4r4r4_s_r4r4r4_r4},
    {"os_r4r4r4_s_r4r4r4_r4i4", w_os_r4r4r4_s_r4r4r4_r4i4},
    {"os_r4r4r4_s_r4r4r4_r4i4i4", w_os_r4r4r4_s_r4r4r4_r4i4i4},
    {"os_r4r4r4_s_r4r4r4_r4s_r4r4r4_", w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_},
    {"os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4", w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4},
    {"os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4", w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4},
    {"os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4", w_os_r4r4r4_s_r4r4r4_r4s_r4r4r4_r4i4i4},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4_", w_os_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4", w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4", w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4", w_os_r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4i4i4},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4", w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4},
    {"os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4", w_os_r4r4r4_s_r4r4r4_s_r4r4r4r4_i4i4},
    {"os_r4r4r4r4r4r4_", w_os_r4r4r4r4r4r4_},
    {"os_r4r4r4r4r4r4_r4", w_os_r4r4r4r4r4r4_r4},
    {"os_r4r4r4r4r4r4_r4i4", w_os_r4r4r4r4r4r4_r4i4},
    {"os_r4r4r4r4r4r4_r4i4i4", w_os_r4r4r4r4r4r4_r4i4i4},
    {"os_r4r4r4r4r4r4_r4r4", w_os_r4r4r4r4r4r4_r4r4},
    {"os_r4r4r4r4r4r4_r4r4i4", w_os_r4r4r4r4r4r4_r4r4i4},
    {"os_r4r4r4r4r4r4_r4r4i4i4", w_os_r4r4r4r4r4r4_r4r4i4i4},
    {"osi4i4i4b", w_osi4i4i4b},
    {"osi4i4i4bo", w_osi4i4i4bo},
    {"osi4i4i4boo", w_osi4i4i4boo},
    {"oso", w_oso},
    {"osoo", w_osoo},
    {"oss", w_oss},
    {"ot", w_ot},
    {"oti4", w_oti4},
    {"oti4b", w_oti4b},
    {"oti4i4", w_oti4i4},
    {"oto", w_oto},
    {"otob", w_otob},
    {"ots", w_ots},
    {"otsO", w_otsO},
    {"ots_r4r4r4_", w_ots_r4r4r4_},
    {"ots_r4r4r4_r4", w_ots_r4r4r4_r4},
    {"ots_r4r4r4_r4i4", w_ots_r4r4r4_r4i4},
    {"p", w_p},
    {"pi4", w_pi4},
    {"pi4pp", w_pi4pp},
    {"po", w_po},
    {"pop", w_pop},
    {"pp", w_pp},
    {"ppi4", w_ppi4},
    {"ppo", w_ppo},
    {"ppp", w_ppp},
    {"pppb", w_pppb},
    {"pppo", w_pppo},
    {"pps", w_pps},
    {"ppsob", w_ppsob},
    {"ppss", w_ppss},
    {"ppssb", w_ppssb},
    {"ps", w_ps},
    {"pt", w_pt},
    {"pti4", w_pti4},
    {"r4", w_r4},
    {"r4Vr4", w_r4Vr4},
    {"r4i4", w_r4i4},
    {"r4pi4", w_r4pi4},
    {"r4pp", w_r4pp},
    {"r4ppo", w_r4ppo},
    {"r4r4", w_r4r4},
    {"r4r4r4", w_r4r4r4},
    {"r4r4r4Pr4r4", w_r4r4r4Pr4r4},
    {"r4r4r4Pr4r4r4", w_r4r4r4Pr4r4r4},
    {"r4r4r4Pr4r4r4r4", w_r4r4r4Pr4r4r4r4},
    {"r4r4r4r4", w_r4r4r4r4},
    {"r4s", w_r4s},
    {"r4s_r4r4_", w_r4s_r4r4_},
    {"r4s_r4r4_s_r4r4_", w_r4s_r4r4_s_r4r4_},
    {"r4s_r4r4r4_", w_r4s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"r4s_r4r4r4r4_", w_r4s_r4r4r4r4_},
    {"r4s_r4r4r4r4_s_r4r4r4r4_", w_r4s_r4r4r4r4_s_r4r4r4r4_},
    {"r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"r4t", w_r4t},
    {"r4ti4", w_r4ti4},
    {"r4ti4i4", w_r4ti4i4},
    {"r4tr4", w_r4tr4},
    {"r4ts", w_r4ts},
    {"r4ts_r4r4r4_", w_r4ts_r4r4r4_},
    {"r4u2", w_r4u2},
    {"r8", w_r8},
    {"r8pi4", w_r8pi4},
    {"r8pp", w_r8pp},
    {"r8ppo", w_r8ppo},
    {"s", w_s},
    {"sO", w_sO},
    {"s_Ppi4i4i4pi4i4o_i4", w_s_Ppi4i4i4pi4i4o_i4},
    {"s_Ppi4i4i4pi4i4o_o", w_s_Ppi4i4i4pi4i4o_o},
    {"s_Pvi4i4i4pi4i4oi4_t", w_s_Pvi4i4i4pi4i4oi4_t},
    {"s_i4_", w_s_i4_},
    {"s_i4_t", w_s_i4_t},
    {"s_i4_ti4i4s_i4_", w_s_i4_ti4i4s_i4_},
    {"s_i4_ti4s_i4_", w_s_i4_ti4s_i4_},
    {"s_i4i4_", w_s_i4i4_},
    {"s_i4i4i4_", w_s_i4i4i4_},
    {"s_i4i4i4br4r4bi4_ti4", w_s_i4i4i4br4r4bi4_ti4},
    {"s_i4i4i4i4_ti4", w_s_i4i4i4i4_ti4},
    {"s_i4i4i4i4b_t", w_s_i4i4i4i4b_t},
    {"s_i4i4i4r4r4r4r4i4i4_ti4", w_s_i4i4i4r4r4r4r4i4i4_ti4},
    {"s_i4oor4r4r4r4r4r4r4r4_t", w_s_i4oor4r4r4r4r4r4r4r4_t},
    {"s_i4r4oor4r4_t", w_s_i4r4oor4r4_t},
    {"s_i4r4r4r4r4r4r4r4i4i4i4r4r4r4r4r4r4_i4", w_s_i4r4r4r4r4r4r4r4i4i4i4r4r4r4r4r4r4_i4},
    {"s_o_t", w_s_o_t},
    {"s_ooooi4i4_t", w_s_ooooi4i4_t},
    {"s_or4r4r4r4i4r4br4i4i4bbi4i4bi4i4r4r4r4r4b_ts_r4r4_", w_s_or4r4r4r4i4r4br4i4i4bbi4i4bi4i4r4r4r4r4b_ts_r4r4_},
    {"s_p_t", w_s_p_t},
    {"s_pu4_t", w_s_pu4_t},
    {"s_r4r4_", w_s_r4r4_},
    {"s_r4r4_i4", w_s_r4r4_i4},
    {"s_r4r4_r4s_r4r4_", w_s_r4r4_r4s_r4r4_},
    {"s_r4r4_s_r4r4_", w_s_r4r4_s_r4r4_},
    {"s_r4r4_s_r4r4_r4", w_s_r4r4_s_r4r4_r4},
    {"s_r4r4_s_r4r4_s_r4r4_", w_s_r4r4_s_r4r4_s_r4r4_},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4},
    {"s_r4r4_s_r4r4_s_r4r4_r4", w_s_r4r4_s_r4r4_s_r4r4_r4},
    {"s_r4r4_s_r4r4r4_", w_s_r4r4_s_r4r4r4_},
    {"s_r4r4_s_r4r4r4r4_", w_s_r4r4_s_r4r4r4r4_},
    {"s_r4r4_s_r4r4r4r4_s_r4r4_", w_s_r4r4_s_r4r4r4r4_s_r4r4_},
    {"s_r4r4_t", w_s_r4r4_t},
    {"s_r4r4_ti4", w_s_r4r4_ti4},
    {"s_r4r4_ts", w_s_r4r4_ts},
    {"s_r4r4r4_", w_s_r4r4r4_},
    {"s_r4r4r4_r4s_r4r4r4_", w_s_r4r4r4_r4s_r4r4r4_},
    {"s_r4r4r4_s_r4r4_", w_s_r4r4r4_s_r4r4_},
    {"s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_os_r4r4r4_s_r4r4r4r4_", w_s_r4r4r4_s_r4r4r4_os_r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4},
    {"s_r4r4r4_s_r4r4r4r4_", w_s_r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_t", w_s_r4r4r4_t},
    {"s_r4r4r4_ti4", w_s_r4r4r4_ti4},
    {"s_r4r4r4_tr4", w_s_r4r4r4_tr4},
    {"s_r4r4r4_tr4r4r4", w_s_r4r4r4_tr4r4r4},
    {"s_r4r4r4_ts_r4r4r4_", w_s_r4r4r4_ts_r4r4r4_},
    {"s_r4r4r4_ts_r4r4r4_i4", w_s_r4r4r4_ts_r4r4r4_i4},
    {"s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t", w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t},
    {"s_r4r4r4r4_", w_s_r4r4r4r4_},
    {"s_r4r4r4r4_i4", w_s_r4r4r4r4_i4},
    {"s_r4r4r4r4_r4", w_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_r4r4r4", w_s_r4r4r4r4_r4r4r4},
    {"s_r4r4r4r4_r4r4r4b", w_s_r4r4r4r4_r4r4r4b},
    {"s_r4r4r4r4_r4r4r4r4", w_s_r4r4r4r4_r4r4r4r4},
    {"s_r4r4r4r4_r4s_r4r4r4_", w_s_r4r4r4r4_r4s_r4r4r4_},
    {"s_r4r4r4r4_r4s_r4r4r4r4_", w_s_r4r4r4r4_r4s_r4r4r4r4_},
    {"s_r4r4r4r4_s", w_s_r4r4r4r4_s},
    {"s_r4r4r4r4_s_r4r4_", w_s_r4r4r4r4_s_r4r4_},
    {"s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_r4", w_s_r4r4r4r4_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4", w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_t", w_s_r4r4r4r4_t},
    {"s_r4r4r4r4_ti4", w_s_r4r4r4r4_ti4},
    {"s_r4r4r4r4_ts", w_s_r4r4r4r4_ts},
    {"s_r4r4r4r4_ts_r4r4r4r4_", w_s_r4r4r4r4_ts_r4r4r4r4_},
    {"s_r4r4r4r4i4i4r4r4_ti4", w_s_r4r4r4r4i4i4r4r4_ti4},
    {"s_r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4_t},
    {"s_r4r4r4r4r4r4_ts_r4r4r4_", w_s_r4r4r4r4r4r4_ts_r4r4r4_},
    {"s_r4r4r4r4r4r4_ts_r4r4r4_i4", w_s_r4r4r4r4r4r4_ts_r4r4r4_i4},
    {"s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4", w_s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4},
    {"s_r4r4r4r4r4r4i4i4r4_ti4", w_s_r4r4r4r4r4r4i4i4r4_ti4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_},
    {"s_u8i4i4u4u4i4i4i4i4s_", w_s_u8i4i4u4u4i4i4i4i4s_},
    {"s_u8u8_t", w_s_u8u8_t},
    {"so", w_so},
    {"sp", w_sp},
    {"spp", w_spp},
    {"sppo", w_sppo},
    {"ss", w_ss},
    {"sso", w_sso},
    {"st", w_st},
    {"sti4", w_sti4},
    {"sts", w_sts},
    {"stsPs", w_stsPs},
    {"stsb", w_stsb},
    {"stsbs", w_stsbs},
    {"stso", w_stso},
    {"u2r4", w_u2r4},
    {"u4t", w_u4t},
    {"u4ti4", w_u4ti4},
    {"u8", w_u8},
    {"u8t", w_u8t},
    {"v", w_v},
    {"vO", w_vO},
    {"vOo", w_vOo},
    {"vPs_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_},
    {"vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_", w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_},
    {"vPs_su4_", w_vPs_su4_},
    {"vPs_su4_b", w_vPs_su4_b},
    {"vb", w_vb},
    {"vbO", w_vbO},
    {"vbOo", w_vbOo},
    {"vbo", w_vbo},
    {"vbosVO", w_vbosVO},
    {"vbs", w_vbs},
    {"vbsVO", w_vbsVO},
    {"vbso", w_vbso},
    {"vi4", w_vi4},
    {"vi4b", w_vi4b},
    {"vi4i4", w_vi4i4},
    {"vi4i4b", w_vi4i4b},
    {"vi4i4bi4", w_vi4i4bi4},
    {"vi4i4i4", w_vi4i4i4},
    {"vi4i4i4i4", w_vi4i4i4i4},
    {"vi4i4osVO", w_vi4i4osVO},
    {"vi4o", w_vi4o},
    {"vi4oi4", w_vi4oi4},
    {"vi4oi4i4", w_vi4oi4i4},
    {"vi4r4", w_vi4r4},
    {"vi4s_r4r4r4r4_", w_vi4s_r4r4r4r4_},
    {"vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vo", w_vo},
    {"voDbDb", w_voDbDb},
    {"vob", w_vob},
    {"voi4", w_voi4},
    {"voi4i4", w_voi4i4},
    {"voo", w_voo},
    {"voob", w_voob},
    {"vooooooo", w_vooooooo},
    {"voooooooo", w_voooooooo},
    {"vooooooooo", w_vooooooooo},
    {"voooooooooo", w_voooooooooo},
    {"vor4", w_vor4},
    {"vosVO", w_vosVO},
    {"vp", w_vp},
    {"vpi4b", w_vpi4b},
    {"vpi4c", w_vpi4c},
    {"vpi4i1", w_vpi4i1},
    {"vpi4i2", w_vpi4i2},
    {"vpi4i4", w_vpi4i4},
    {"vpi4i8", w_vpi4i8},
    {"vpi4p", w_vpi4p},
    {"vpi4r4", w_vpi4r4},
    {"vpi4r8", w_vpi4r8},
    {"vppb", w_vppb},
    {"vppc", w_vppc},
    {"vppi1", w_vppi1},
    {"vppi2", w_vppi2},
    {"vppi4", w_vppi4},
    {"vppi8", w_vppi8},
    {"vppo", w_vppo},
    {"vppp", w_vppp},
    {"vppr4", w_vppr4},
    {"vppr8", w_vppr8},
    {"vpps", w_vpps},
    {"vr4", w_vr4},
    {"vs", w_vs},
    {"vsVO", w_vsVO},
    {"vs_Ppi4i4i4pi4i4o_oDi4", w_vs_Ppi4i4i4pi4i4o_oDi4},
    {"vs_Pvi4i4i4pi4i4oi4_o", w_vs_Pvi4i4i4pi4i4oi4_o},
    {"vs_r4r4_", w_vs_r4r4_},
    {"vs_r4r4r4_", w_vs_r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_", w_vs_r4r4r4_s_r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b},
    {"vs_r4r4r4r4_Pr4Pr4Pr4", w_vs_r4r4r4r4_Pr4Pr4Pr4},
    {"vs_r4r4r4r4r4r4_i4", w_vs_r4r4r4r4r4r4_i4},
    {"vsi4", w_vsi4},
    {"vso", w_vso},
    {"vsoi4", w_vsoi4},
    {"vsoi4i4", w_vsoi4i4},
    {"vsr4", w_vsr4},
    {"vss_r4r4r4r4_", w_vss_r4r4r4r4_},
    {"vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vt", w_vt},
    {"vtDr4", w_vtDr4},
    {"vtPr4Ps_r4r4r4_", w_vtPr4Ps_r4r4r4_},
    {"vtPs_psu4_", w_vtPs_psu4_},
    {"vtPs_psu4_b", w_vtPs_psu4_b},
    {"vtPs_r4r4r4_Ps_r4r4r4r4_", w_vtPs_r4r4r4_Ps_r4r4r4r4_},
    {"vtVs_r4r4r4r4i4i4r4r4_", w_vtVs_r4r4r4r4i4i4r4r4_},
    {"vtb", w_vtb},
    {"vtbi4", w_vtbi4},
    {"vti4", w_vti4},
    {"vti4Dr4", w_vti4Dr4},
    {"vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_", w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_},
    {"vti4Vs_i4i4i4i4_", w_vti4Vs_i4i4i4i4_},
    {"vti4b", w_vti4b},
    {"vti4i4", w_vti4i4},
    {"vti4i4o", w_vti4i4o},
    {"vti4i4ooo", w_vti4i4ooo},
    {"vti4i4r4", w_vti4i4r4},
    {"vti4o", w_vti4o},
    {"vti4oi4", w_vti4oi4},
    {"vti4oi4i4", w_vti4oi4i4},
    {"vti4oi4i4i4", w_vti4oi4i4i4},
    {"vti4r4", w_vti4r4},
    {"vti4r4i4", w_vti4r4i4},
    {"vti4r4i4r4", w_vti4r4i4r4},
    {"vti4r4i4r4r4", w_vti4r4i4r4r4},
    {"vti4r4r4", w_vti4r4r4},
    {"vti4r4r4r4", w_vti4r4r4r4},
    {"vti4s_Pvi4i4i4pi4i4oi4_", w_vti4s_Pvi4i4i4pi4i4oi4_},
    {"vti4s_r4r4_", w_vti4s_r4r4_},
    {"vti4s_r4r4r4_", w_vti4s_r4r4r4_},
    {"vti4s_r4r4r4r4_", w_vti4s_r4r4r4r4_},
    {"vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4", w_vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4},
    {"vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vto", w_vto},
    {"vtoDb", w_vtoDb},
    {"vtoDi4", w_vtoDi4},
    {"vtob", w_vtob},
    {"vtobb", w_vtobb},
    {"vtobbb", w_vtobbb},
    {"vtoi4", w_vtoi4},
    {"vtoi4Db", w_vtoi4Db},
    {"vtoi4DbDi4", w_vtoi4DbDi4},
    {"vtoi4b", w_vtoi4b},
    {"vtoi4bi4", w_vtoi4bi4},
    {"vtoi4i4", w_vtoi4i4},
    {"vtoi4i4DbDi4", w_vtoi4i4DbDi4},
    {"vtoi4i4Di4", w_vtoi4i4Di4},
    {"vtoi4i4b", w_vtoi4i4b},
    {"vtoi4i4bi4", w_vtoi4i4bi4},
    {"vtoi4i4i4", w_vtoi4i4i4},
    {"vtoi4i4i4DbDi4", w_vtoi4i4i4DbDi4},
    {"vtoi4i4i4i4DbDi4", w_vtoi4i4i4i4DbDi4},
    {"vtoo", w_vtoo},
    {"vtooDb", w_vtooDb},
    {"vtoor4", w_vtoor4},
    {"vtor4", w_vtor4},
    {"vtos", w_vtos},
    {"vtos_i4p_", w_vtos_i4p_},
    {"vtos_r4r4r4_", w_vtos_r4r4r4_},
    {"vtosoo", w_vtosoo},
    {"vtr4", w_vtr4},
    {"vtr4b", w_vtr4b},
    {"vtr4bb", w_vtr4bb},
    {"vtr4bbb", w_vtr4bbb},
    {"vtr4r4", w_vtr4r4},
    {"vtr4r4r4", w_vtr4r4r4},
    {"vtr4r4r4i4", w_vtr4r4r4i4},
    {"vtr4r4r4o", w_vtr4r4r4o},
    {"vtr4r4r4r4", w_vtr4r4r4r4},
    {"vtr4r4r4r4r4", w_vtr4r4r4r4r4},
    {"vtr4s_r4r4r4_r4", w_vtr4s_r4r4r4_r4},
    {"vtr4s_r4r4r4_r4r4", w_vtr4s_r4r4r4_r4r4},
    {"vtr4s_r4r4r4_r4r4i4", w_vtr4s_r4r4r4_r4r4i4},
    {"vts", w_vts},
    {"vtsO", w_vtsO},
    {"vtsOi4", w_vtsOi4},
    {"vtsVo", w_vtsVo},
    {"vts_Pvi4i4i4pi4i4oi4_", w_vts_Pvi4i4i4pi4i4oi4_},
    {"vts_Pvi4i4i4pi4i4oi4_i4", w_vts_Pvi4i4i4pi4i4oi4_i4},
    {"vts_Pvi4i4i4pi4i4oi4_i4i4", w_vts_Pvi4i4i4pi4i4oi4_i4i4},
    {"vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_", w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_},
    {"vts_i4_", w_vts_i4_},
    {"vts_i4i4i4i4b_", w_vts_i4i4i4i4b_},
    {"vts_i4oor4r4r4r4r4r4r4r4_", w_vts_i4oor4r4r4r4r4r4r4r4_},
    {"vts_i4p_s_i4p_", w_vts_i4p_s_i4p_},
    {"vts_i4r4oor4r4_", w_vts_i4r4oor4r4_},
    {"vts_ooooi4i4_", w_vts_ooooi4i4_},
    {"vts_r4r4_", w_vts_r4r4_},
    {"vts_r4r4_s_r4r4_", w_vts_r4r4_s_r4r4_},
    {"vts_r4r4r4_", w_vts_r4r4r4_},
    {"vts_r4r4r4_i4", w_vts_r4r4r4_i4},
    {"vts_r4r4r4_o", w_vts_r4r4r4_o},
    {"vts_r4r4r4_r4", w_vts_r4r4r4_r4},
    {"vts_r4r4r4_r4i4", w_vts_r4r4r4_r4i4},
    {"vts_r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4_i4", w_vts_r4r4r4_s_r4r4r4_i4},
    {"vts_r4r4r4_s_r4r4r4_r4", w_vts_r4r4r4_s_r4r4r4_r4},
    {"vts_r4r4r4_s_r4r4r4r4_", w_vts_r4r4r4_s_r4r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4", w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4},
    {"vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4", w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4},
    {"vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4b", w_vts_r4r4r4_s_r4r4r4r4_i4s_r4r4r4r4_r4r4b},
    {"vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_", w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_},
    {"vts_r4r4r4r4_", w_vts_r4r4r4r4_},
    {"vts_r4r4r4r4_r4i4o", w_vts_r4r4r4r4_r4i4o},
    {"vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_", w_vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_},
    {"vts_r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4},
    {"vts_u8u8_", w_vts_u8u8_},
    {"vtsb", w_vtsb},
    {"vtsi4", w_vtsi4},
    {"vtsi4r4", w_vtsi4r4},
    {"vtso", w_vtso},
    {"vtsoi4", w_vtsoi4},
    {"vtsoi4i4", w_vtsoi4i4},
    {"vtsoso", w_vtsoso},
    {"vtsr4", w_vtsr4},
    {"vtsr4i4", w_vtsr4i4},
    {"vtsr4i4r4", w_vtsr4i4r4},
    {"vtsr4i4r4r4", w_vtsr4i4r4r4},
    {"vtsr4ooo", w_vtsr4ooo},
    {"vtsr4r4", w_vtsr4r4},
    {"vtsr4r4r4", w_vtsr4r4r4},
    {"vtss", w_vtss},
    {"vtss_r4r4_", w_vtss_r4r4_},
    {"vtss_r4r4r4r4_", w_vtss_r4r4r4r4_},
    {"vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtssoo", w_vtssoo},
    {"vtu4", w_vtu4},
    {"vtu8", w_vtu8},
    {nullptr, nullptr}
};


static void* b_O(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_O");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OVO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OVO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    auto arrayLength = GetArrayLength(p0);
    v8::Local<v8::Value> *Argv = (v8::Local<v8::Value> *)alloca(sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    memset(Argv, 0, sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    
    RestArguments<void*>::UnPackRefOrBoxedValueType(context, p0, arrayLength, TIp0, Argv + 0);
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1 + arrayLength - 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_Oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oppi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oppi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Os_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Os_oooObr4r4r4r4bb_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Oso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static bool b_b(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bOooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bOooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs(void* target, void** p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_(void* target, struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4i4i4po(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4i4i4po");

    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPi4(void* target, void* p0, int32_t* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boPi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPsPs(void* target, void* p0, void** p1, void** p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boPsPs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4O(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4O");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_booi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_boooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_booso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bososo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bososo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosss(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bossss(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bossss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bp");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* target, struct s_r4r4_ p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_sOO_(void* target, struct s_sOO_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_sOO_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8u8u4u4u4u4i4oo_oo(void* target, struct s_u8u8u4u4u4u4i4oo_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8u8u4u4u4u4i4oo_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsbi4s(void* target, void* p0, bool p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsbi4s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bu1o(void* target, uint8_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bu1o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint8_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static Il2CppChar b_csi4c(void* target, void* p0, int32_t p1, Il2CppChar p2, void* method) {
    // PLog(LogLevel::Log, "Running b_csi4c");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<Il2CppChar>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    Il2CppChar ret = converter::Converter<Il2CppChar>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int16_t b_i2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int16_t ret = converter::Converter<int16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4i4ob(void* target, int32_t p0, int32_t p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4i4ob");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4sb(void* target, int32_t p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4sb");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os_r4r4r4_s_r4r4_ob(void* target, void* p0, struct s_r4r4r4_ p1, struct s_r4r4_ p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os_r4r4r4_s_r4r4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_(void* target, struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_o(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_o");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOs(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOs");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOsooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oOsooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_(void* target, struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4oo(void* target, int32_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4s(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4s");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi8oo(void* target, int64_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi8oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4s_r4r4_ooPi4(void* target, void* p0, int32_t p1, struct s_r4r4_ p2, void* p3, void* p4, int32_t* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4s_r4r4_ooPi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi8o(void* target, void* p0, void* p1, int64_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi8o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooor4(void* target, void* p0, void* p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooor4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooos_r4r4_i4(void* target, void* p0, void* p1, struct s_r4r4_ p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooos_r4r4_i4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosb");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosu8(void* target, void* p0, void* p1, uint64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosu8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<uint64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oou4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oou4u4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_os");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_os_i4i4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os_r4r4r4r4_o(void* target, struct s_r4r4r4r4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_os_r4r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_osi4o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_osooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_pp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_pp");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_pppi4i8(void* target, void* p0, void* p1, int32_t p2, int64_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_pppi4i8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4i4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4Ps_r4r4r4r4_(void* target, float p0, struct s_r4r4r4r4_* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4Ps_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4s_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4s_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_s(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_sO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static struct s__ b_s__(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s__");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s__* pret = DataTransfer::GetPointer<s__>(context, MaybeRet.ToLocalChecked());
    s__ ret = pret ? *pret : s__ {};
    return ret;
        
}

static struct s_bi4_ b_s_bi4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4_* pret = DataTransfer::GetPointer<s_bi4_>(context, MaybeRet.ToLocalChecked());
    s_bi4_ ret = pret ? *pret : s_bi4_ {};
    return ret;
        
}

static struct s_bi4i4i4i4u8_ b_s_bi4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4i4i4i4u8_* pret = DataTransfer::GetPointer<s_bi4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_bi4i4i4i4u8_ ret = pret ? *pret : s_bi4i4i4i4u8_ {};
    return ret;
        
}

static struct s_bi8_ b_s_bi8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi8_* pret = DataTransfer::GetPointer<s_bi8_>(context, MaybeRet.ToLocalChecked());
    s_bi8_ ret = pret ? *pret : s_bi8_ {};
    return ret;
        
}

static struct s_bo_ b_s_bo_s(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bo_s");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bo_* pret = DataTransfer::GetPointer<s_bo_>(context, MaybeRet.ToLocalChecked());
    s_bo_ ret = pret ? *pret : s_bo_ {};
    return ret;
        
}

static struct s_br4_ b_s_br4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br4_* pret = DataTransfer::GetPointer<s_br4_>(context, MaybeRet.ToLocalChecked());
    s_br4_ ret = pret ? *pret : s_br4_ {};
    return ret;
        
}

static struct s_br8_ b_s_br8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br8_* pret = DataTransfer::GetPointer<s_br8_>(context, MaybeRet.ToLocalChecked());
    s_br8_ ret = pret ? *pret : s_br8_ {};
    return ret;
        
}

static struct s_i4i4i4i4u8_ b_s_i4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_i4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4u8_* pret = DataTransfer::GetPointer<s_i4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_i4i4i4i4u8_ ret = pret ? *pret : s_i4i4i4i4u8_ {};
    return ret;
        
}

static struct s_ooor4r4_ b_s_ooor4r4_s_ooor4r4_(void* target, struct s_ooor4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ooor4r4_s_ooor4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ooor4r4_* pret = DataTransfer::GetPointer<s_ooor4r4_>(context, MaybeRet.ToLocalChecked());
    s_ooor4r4_ ret = pret ? *pret : s_ooor4r4_ {};
    return ret;
        
}

static struct s_ossi4i4i4i4o_ b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ossi4i4i4i4o_* pret = DataTransfer::GetPointer<s_ossi4i4i4i4o_>(context, MaybeRet.ToLocalChecked());
    s_ossi4i4i4i4o_ ret = pret ? *pret : s_ossi4i4i4i4o_ {};
    return ret;
        
}

static struct s_pi4_ b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_pi4_* pret = DataTransfer::GetPointer<s_pi4_>(context, MaybeRet.ToLocalChecked());
    s_pi4_ ret = pret ? *pret : s_pi4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_s_r4r4_(void* target, struct s_r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_s_r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4_ b_s_r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4_ ret = pret ? *pret : s_r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4_ b_s_r4r4r4r4_(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4_");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4_ b_s_r4r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4r4r4_ b_s_r4r4r4r4r4r4_(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4r4r4_ {};
    return ret;
        
}

static struct s_u8_ b_s_u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_u8_* pret = DataTransfer::GetPointer<s_u8_>(context, MaybeRet.ToLocalChecked());
    s_u8_ ret = pret ? *pret : s_u8_ {};
    return ret;
        
}

static void* b_si4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_si4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_so(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_so");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sob");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_soo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_soo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss_oi4osi4u1u1u1u1_(void* target, struct s_oi4osi4u1u1u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss_oi4osi4u1u1u1u1_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static uint16_t b_u2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint16_t ret = converter::Converter<uint16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4u4pu4(void* target, uint32_t p0, void* p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_u4u4pu4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint64_t b_u8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint64_t ret = converter::Converter<uint64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void b_v(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_v");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vODo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vODo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOoi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOoi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOsO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_(void* target, void* p0, struct s_Oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_o(void* target, void* p0, struct s_Oi4_ p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_(void* target, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbbi4(void* target, bool p0, bool p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbbi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbs(void* target, bool p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vbs");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbso(void* target, bool p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbso");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4O(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4O");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4(void* target, int32_t p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4i4p(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4i4p");

    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i8i8b(void* target, int32_t p0, int64_t p1, int64_t p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i8i8b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4o(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popO(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popO");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popo(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popo");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4_s_r4r4r4r4_r4i4(void* target, int32_t p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, int32_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4_s_r4r4r4r4_r4i4");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<float>::toScript(context, p3),
        converter::Converter<int32_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4r4_(void* target, int32_t p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8(void* target, int64_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int64_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8i8(void* target, int64_t p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8i8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8o(void* target, int64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4i4(void* target, void* p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4oo(void* target, void* p0, int32_t p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8i8i8i8i8i8i8(void* target, void* p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, int64_t p5, int64_t p6, int64_t p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8i8i8i8i8i8i8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4),
        converter::Converter<int64_t>::toScript(context, p5),
        converter::Converter<int64_t>::toScript(context, p6),
        converter::Converter<int64_t>::toScript(context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi8(void* target, void* p0, void* p1, int64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voos(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor4(void* target, void* p0, float p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<float>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor8(void* target, void* p0, double p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<double>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_Pvi4i4i4pi4i4oi4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_(void* target, void* p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_ob(void* target, void* p0, struct s_i4_ p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4i4i4i4_b(void* target, void* p0, struct s_i4i4i4i4_ p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_oi4osi4u1u1u1u1_(void* target, void* p0, struct s_oi4osi4u1u1u1u1_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_oi4osi4u1u1u1u1_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4_(void* target, void* p0, struct s_r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4_(void* target, void* p0, struct s_r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_sosi4i4i4i4i4_i4(void* target, void* p0, struct s_sosi4i4i4i4i4_ p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_sosi4i4i4i4i4_i4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vosb");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voss_i4i4i4i4_b(void* target, void* p0, void* p1, struct s_i4i4i4i4_ p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voss_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vou4(void* target, void* p0, uint32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vou4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4i8(void* target, void* p0, void* p1, void* p2, int32_t p3, int64_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4i8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4u4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4Ps_r4r4r4r4_Pr4Pr4(void* target, float p0, struct s_r4r4r4r4_* p1, float* p2, float* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4Ps_r4r4r4r4_Pr4Pr4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_Oi4_(void* target, struct s_Oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs__(void* target, struct s__ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs__");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_(void* target, struct s_i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_b(void* target, struct s_i4_ p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_b");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4(void* target, struct s_i4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4i4(void* target, struct s_i4_ p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s(void* target, struct s_i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_Pvi4i4i4pi4i4oi4_(void* target, struct s_i4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_i4_(void* target, struct s_i4_ p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_(void* target, struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_(void* target, struct s_i4i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_o(void* target, struct s_i4i8_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4o_(void* target, struct s_i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4osu8i8_(void* target, struct s_i4osu8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4osu8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4r4r4i4_(void* target, struct s_i4r4r4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4r4r4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4u1u1_(void* target, struct s_i4u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4u1u1_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i8i8_(void* target, struct s_i8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oo_(void* target, struct s_oo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oob_(void* target, struct s_oob_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oob_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oooObr4r4r4r4bb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ossi4i4i4i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_(void* target, struct s_pi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_o(void* target, struct s_pi4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ppi4i4_o(void* target, struct s_ppi4i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ppi4i4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pu4_(void* target, struct s_pu4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pu4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4_(void* target, struct s_r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4oi4_(void* target, struct s_r4r4oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_(void* target, struct s_r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4(void* target, struct s_r4r4r4r4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4bb(void* target, struct s_r4r4r4r4_ p0, int32_t p1, bool p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4bb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<bool>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_o(void* target, struct s_r4r4r4r4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_oo(void* target, struct s_r4r4r4r4_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_so_(void* target, struct s_so_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_so_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_soo_(void* target, struct s_soo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_soo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ss_(void* target, struct s_ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8b_(void* target, struct s_u8b_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8b_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_(void* target, struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs(void* target, void* p0, bool p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_(void* target, void* p0, bool p1, struct s_Pvi4i4i4pi4i4oi4i4i4i4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsoo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsoo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vssi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vssi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu1(void* target, uint8_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vu1");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<uint8_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4u4Ps_ppi4i4p_(void* target, uint32_t p0, uint32_t p1, struct s_ppi4i4p_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4u4Ps_ppi4i4p_");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu8o(void* target, uint64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vu8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static BridgeFuncInfo g_bridgeFuncInfos[] = {
    
    {"O", (MethodPointer)b_O},
    {"OO", (MethodPointer)b_OO},
    {"OVO", (MethodPointer)b_OVO},
    {"Oi4popb", (MethodPointer)b_Oi4popb},
    {"Oo", (MethodPointer)b_Oo},
    {"Ooo", (MethodPointer)b_Ooo},
    {"Oooo", (MethodPointer)b_Oooo},
    {"Oppi4", (MethodPointer)b_Oppi4},
    {"Os_oooObr4r4r4r4bb_", (MethodPointer)b_Os_oooObr4r4r4r4bb_},
    {"Oso", (MethodPointer)b_Oso},
    {"b", (MethodPointer)b_b},
    {"bO", (MethodPointer)b_bO},
    {"bOooi4", (MethodPointer)b_bOooi4},
    {"bPs", (MethodPointer)b_bPs},
    {"bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_", (MethodPointer)b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_},
    {"bb", (MethodPointer)b_bb},
    {"bi4", (MethodPointer)b_bi4},
    {"bi4i4i4po", (MethodPointer)b_bi4i4i4po},
    {"bo", (MethodPointer)b_bo},
    {"boO", (MethodPointer)b_boO},
    {"boPi4", (MethodPointer)b_boPi4},
    {"boPsPs", (MethodPointer)b_boPsPs},
    {"boi4", (MethodPointer)b_boi4},
    {"boi4O", (MethodPointer)b_boi4O},
    {"boo", (MethodPointer)b_boo},
    {"booi4", (MethodPointer)b_booi4},
    {"boooi4", (MethodPointer)b_boooi4},
    {"booso", (MethodPointer)b_booso},
    {"boso", (MethodPointer)b_boso},
    {"bososo", (MethodPointer)b_bososo},
    {"bosso", (MethodPointer)b_bosso},
    {"bosss", (MethodPointer)b_bosss},
    {"bossss", (MethodPointer)b_bossss},
    {"bp", (MethodPointer)b_bp},
    {"bs", (MethodPointer)b_bs},
    {"bsO", (MethodPointer)b_bsO},
    {"bs_i4ss_", (MethodPointer)b_bs_i4ss_},
    {"bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_", (MethodPointer)b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"bs_sOO_", (MethodPointer)b_bs_sOO_},
    {"bs_u8_", (MethodPointer)b_bs_u8_},
    {"bs_u8u8u4u4u4u4i4oo_oo", (MethodPointer)b_bs_u8u8u4u4u4u4i4oo_oo},
    {"bsbi4s", (MethodPointer)b_bsbi4s},
    {"bsooi4", (MethodPointer)b_bsooi4},
    {"bu1o", (MethodPointer)b_bu1o},
    {"csi4c", (MethodPointer)b_csi4c},
    {"i2os", (MethodPointer)b_i2os},
    {"i4", (MethodPointer)b_i4},
    {"i4i4i4ob", (MethodPointer)b_i4i4i4ob},
    {"i4i4sb", (MethodPointer)b_i4i4sb},
    {"i4o", (MethodPointer)b_i4o},
    {"i4ob", (MethodPointer)b_i4ob},
    {"i4oi4o", (MethodPointer)b_i4oi4o},
    {"i4oo", (MethodPointer)b_i4oo},
    {"i4os", (MethodPointer)b_i4os},
    {"i4os_r4r4r4_s_r4r4_ob", (MethodPointer)b_i4os_r4r4r4_s_r4r4_ob},
    {"i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_", (MethodPointer)b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_},
    {"i4ss", (MethodPointer)b_i4ss},
    {"i8o", (MethodPointer)b_i8o},
    {"i8os", (MethodPointer)b_i8os},
    {"o", (MethodPointer)b_o},
    {"oO", (MethodPointer)b_oO},
    {"oOo", (MethodPointer)b_oOo},
    {"oOs", (MethodPointer)b_oOs},
    {"oOsooo", (MethodPointer)b_oOsooo},
    {"oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_", (MethodPointer)b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_},
    {"oi4", (MethodPointer)b_oi4},
    {"oi4oo", (MethodPointer)b_oi4oo},
    {"oi4popb", (MethodPointer)b_oi4popb},
    {"oi4s", (MethodPointer)b_oi4s},
    {"oi8oo", (MethodPointer)b_oi8oo},
    {"oo", (MethodPointer)b_oo},
    {"ooO", (MethodPointer)b_ooO},
    {"ooi4", (MethodPointer)b_ooi4},
    {"ooi4s_r4r4_ooPi4", (MethodPointer)b_ooi4s_r4r4_ooPi4},
    {"ooo", (MethodPointer)b_ooo},
    {"oooO", (MethodPointer)b_oooO},
    {"oooi4", (MethodPointer)b_oooi4},
    {"oooi8o", (MethodPointer)b_oooi8o},
    {"oooo", (MethodPointer)b_oooo},
    {"ooooO", (MethodPointer)b_ooooO},
    {"ooooo", (MethodPointer)b_ooooo},
    {"oooooO", (MethodPointer)b_oooooO},
    {"oooooo", (MethodPointer)b_oooooo},
    {"ooooooo", (MethodPointer)b_ooooooo},
    {"oooooooo", (MethodPointer)b_oooooooo},
    {"ooooooooo", (MethodPointer)b_ooooooooo},
    {"oooooooooo", (MethodPointer)b_oooooooooo},
    {"ooooooooooo", (MethodPointer)b_ooooooooooo},
    {"oooooooooooo", (MethodPointer)b_oooooooooooo},
    {"ooooooooooooo", (MethodPointer)b_ooooooooooooo},
    {"oooooooooooooo", (MethodPointer)b_oooooooooooooo},
    {"ooooooooooooooo", (MethodPointer)b_ooooooooooooooo},
    {"oooooooooooooooo", (MethodPointer)b_oooooooooooooooo},
    {"ooooooooooooooooo", (MethodPointer)b_ooooooooooooooooo},
    {"ooor4", (MethodPointer)b_ooor4},
    {"ooos_r4r4_i4", (MethodPointer)b_ooos_r4r4_i4},
    {"oos", (MethodPointer)b_oos},
    {"oosb", (MethodPointer)b_oosb},
    {"ooso", (MethodPointer)b_ooso},
    {"oosu8", (MethodPointer)b_oosu8},
    {"oou4u4", (MethodPointer)b_oou4u4},
    {"os", (MethodPointer)b_os},
    {"os_i4i4_", (MethodPointer)b_os_i4i4_},
    {"os_r4r4r4r4_o", (MethodPointer)b_os_r4r4r4r4_o},
    {"osi4o", (MethodPointer)b_osi4o},
    {"osooo", (MethodPointer)b_osooo},
    {"oss", (MethodPointer)b_oss},
    {"pp", (MethodPointer)b_pp},
    {"pppi4i8", (MethodPointer)b_pppi4i8},
    {"r4", (MethodPointer)b_r4},
    {"r4i4", (MethodPointer)b_r4i4},
    {"r4o", (MethodPointer)b_r4o},
    {"r4os", (MethodPointer)b_r4os},
    {"r4r4", (MethodPointer)b_r4r4},
    {"r4r4Ps_r4r4r4r4_", (MethodPointer)b_r4r4Ps_r4r4r4r4_},
    {"r4s_r4r4r4_", (MethodPointer)b_r4s_r4r4r4_},
    {"r8", (MethodPointer)b_r8},
    {"r8o", (MethodPointer)b_r8o},
    {"r8os", (MethodPointer)b_r8os},
    {"s", (MethodPointer)b_s},
    {"sO", (MethodPointer)b_sO},
    {"s__", (MethodPointer)b_s__},
    {"s_bi4_o", (MethodPointer)b_s_bi4_o},
    {"s_bi4i4i4i4u8_o", (MethodPointer)b_s_bi4i4i4i4u8_o},
    {"s_bi8_o", (MethodPointer)b_s_bi8_o},
    {"s_bo_s", (MethodPointer)b_s_bo_s},
    {"s_br4_o", (MethodPointer)b_s_br4_o},
    {"s_br8_o", (MethodPointer)b_s_br8_o},
    {"s_i4i4i4i4u8_o", (MethodPointer)b_s_i4i4i4i4u8_o},
    {"s_ooor4r4_s_ooor4r4_", (MethodPointer)b_s_ooor4r4_s_ooor4r4_},
    {"s_ossi4i4i4i4o_s_ossi4i4i4i4o_", (MethodPointer)b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_},
    {"s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4_o", (MethodPointer)b_s_r4r4_o},
    {"s_r4r4_s_r4r4_", (MethodPointer)b_s_r4r4_s_r4r4_},
    {"s_r4r4r4_o", (MethodPointer)b_s_r4r4r4_o},
    {"s_r4r4r4r4_", (MethodPointer)b_s_r4r4r4r4_},
    {"s_r4r4r4r4_o", (MethodPointer)b_s_r4r4r4r4_o},
    {"s_r4r4r4r4r4r4_", (MethodPointer)b_s_r4r4r4r4r4r4_},
    {"s_u8_o", (MethodPointer)b_s_u8_o},
    {"si4", (MethodPointer)b_si4},
    {"so", (MethodPointer)b_so},
    {"sob", (MethodPointer)b_sob},
    {"soo", (MethodPointer)b_soo},
    {"sos", (MethodPointer)b_sos},
    {"ss", (MethodPointer)b_ss},
    {"ss_oi4osi4u1u1u1u1_", (MethodPointer)b_ss_oi4osi4u1u1u1u1_},
    {"sso", (MethodPointer)b_sso},
    {"u2os", (MethodPointer)b_u2os},
    {"u4os", (MethodPointer)b_u4os},
    {"u4u4pu4", (MethodPointer)b_u4u4pu4},
    {"u8os", (MethodPointer)b_u8os},
    {"v", (MethodPointer)b_v},
    {"vO", (MethodPointer)b_vO},
    {"vODo", (MethodPointer)b_vODo},
    {"vOO", (MethodPointer)b_vOO},
    {"vOb", (MethodPointer)b_vOb},
    {"vOo", (MethodPointer)b_vOo},
    {"vOoi4", (MethodPointer)b_vOoi4},
    {"vOsO", (MethodPointer)b_vOsO},
    {"vOs_Oi4_", (MethodPointer)b_vOs_Oi4_},
    {"vOs_Oi4_o", (MethodPointer)b_vOs_Oi4_o},
    {"vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_},
    {"vb", (MethodPointer)b_vb},
    {"vbbi4", (MethodPointer)b_vbbi4},
    {"vbs", (MethodPointer)b_vbs},
    {"vbso", (MethodPointer)b_vbso},
    {"vi4", (MethodPointer)b_vi4},
    {"vi4O", (MethodPointer)b_vi4O},
    {"vi4i4", (MethodPointer)b_vi4i4},
    {"vi4i4i4p", (MethodPointer)b_vi4i4i4p},
    {"vi4i8i8b", (MethodPointer)b_vi4i8i8b},
    {"vi4o", (MethodPointer)b_vi4o},
    {"vi4popO", (MethodPointer)b_vi4popO},
    {"vi4popo", (MethodPointer)b_vi4popo},
    {"vi4s", (MethodPointer)b_vi4s},
    {"vi4s_r4r4r4_s_r4r4r4r4_r4i4", (MethodPointer)b_vi4s_r4r4r4_s_r4r4r4r4_r4i4},
    {"vi4s_r4r4r4r4_", (MethodPointer)b_vi4s_r4r4r4r4_},
    {"vi8", (MethodPointer)b_vi8},
    {"vi8i8", (MethodPointer)b_vi8i8},
    {"vi8o", (MethodPointer)b_vi8o},
    {"vo", (MethodPointer)b_vo},
    {"voO", (MethodPointer)b_voO},
    {"vob", (MethodPointer)b_vob},
    {"voi4", (MethodPointer)b_voi4},
    {"voi4i4", (MethodPointer)b_voi4i4},
    {"voi4o", (MethodPointer)b_voi4o},
    {"voi4oo", (MethodPointer)b_voi4oo},
    {"voi8", (MethodPointer)b_voi8},
    {"voi8i8i8i8i8i8i8", (MethodPointer)b_voi8i8i8i8i8i8i8},
    {"voo", (MethodPointer)b_voo},
    {"vooi4", (MethodPointer)b_vooi4},
    {"vooi8", (MethodPointer)b_vooi8},
    {"vooo", (MethodPointer)b_vooo},
    {"voooo", (MethodPointer)b_voooo},
    {"vooooo", (MethodPointer)b_vooooo},
    {"voooooo", (MethodPointer)b_voooooo},
    {"vooooooo", (MethodPointer)b_vooooooo},
    {"voooooooo", (MethodPointer)b_voooooooo},
    {"vooooooooo", (MethodPointer)b_vooooooooo},
    {"voooooooooo", (MethodPointer)b_voooooooooo},
    {"vooooooooooo", (MethodPointer)b_vooooooooooo},
    {"voooooooooooo", (MethodPointer)b_voooooooooooo},
    {"vooooooooooooo", (MethodPointer)b_vooooooooooooo},
    {"voooooooooooooo", (MethodPointer)b_voooooooooooooo},
    {"vooooooooooooooo", (MethodPointer)b_vooooooooooooooo},
    {"voooooooooooooooo", (MethodPointer)b_voooooooooooooooo},
    {"voos", (MethodPointer)b_voos},
    {"vor4", (MethodPointer)b_vor4},
    {"vor8", (MethodPointer)b_vor8},
    {"vos", (MethodPointer)b_vos},
    {"vos_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vos_Pvi4i4i4pi4i4oi4_},
    {"vos_i4_", (MethodPointer)b_vos_i4_},
    {"vos_i4_ob", (MethodPointer)b_vos_i4_ob},
    {"vos_i4i4i4i4_b", (MethodPointer)b_vos_i4i4i4i4_b},
    {"vos_oi4osi4u1u1u1u1_", (MethodPointer)b_vos_oi4osi4u1u1u1u1_},
    {"vos_r4r4_", (MethodPointer)b_vos_r4r4_},
    {"vos_r4r4r4_", (MethodPointer)b_vos_r4r4r4_},
    {"vos_r4r4r4r4_", (MethodPointer)b_vos_r4r4r4r4_},
    {"vos_sosi4i4i4i4i4_i4", (MethodPointer)b_vos_sosi4i4i4i4i4_i4},
    {"vosb", (MethodPointer)b_vosb},
    {"voso", (MethodPointer)b_voso},
    {"voss_i4i4i4i4_b", (MethodPointer)b_voss_i4i4i4i4_b},
    {"vou4", (MethodPointer)b_vou4},
    {"vpi8", (MethodPointer)b_vpi8},
    {"vpppi4", (MethodPointer)b_vpppi4},
    {"vpppi4i8", (MethodPointer)b_vpppi4i8},
    {"vpu4u4", (MethodPointer)b_vpu4u4},
    {"vr4", (MethodPointer)b_vr4},
    {"vr4Ps_r4r4r4r4_Pr4Pr4", (MethodPointer)b_vr4Ps_r4r4r4r4_Pr4Pr4},
    {"vs", (MethodPointer)b_vs},
    {"vs_Oi4_", (MethodPointer)b_vs_Oi4_},
    {"vs__", (MethodPointer)b_vs__},
    {"vs_i4_", (MethodPointer)b_vs_i4_},
    {"vs_i4_b", (MethodPointer)b_vs_i4_b},
    {"vs_i4_i4", (MethodPointer)b_vs_i4_i4},
    {"vs_i4_i4i4", (MethodPointer)b_vs_i4_i4i4},
    {"vs_i4_s", (MethodPointer)b_vs_i4_s},
    {"vs_i4_s_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vs_i4_s_Pvi4i4i4pi4i4oi4_},
    {"vs_i4_s_i4_", (MethodPointer)b_vs_i4_s_i4_},
    {"vs_i4i4_", (MethodPointer)b_vs_i4i4_},
    {"vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_", (MethodPointer)b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_},
    {"vs_i4i8_", (MethodPointer)b_vs_i4i8_},
    {"vs_i4i8_o", (MethodPointer)b_vs_i4i8_o},
    {"vs_i4o_", (MethodPointer)b_vs_i4o_},
    {"vs_i4osu8i8_", (MethodPointer)b_vs_i4osu8i8_},
    {"vs_i4r4r4i4_", (MethodPointer)b_vs_i4r4r4i4_},
    {"vs_i4ss_", (MethodPointer)b_vs_i4ss_},
    {"vs_i4u1u1_", (MethodPointer)b_vs_i4u1u1_},
    {"vs_i8i8_", (MethodPointer)b_vs_i8i8_},
    {"vs_oo_", (MethodPointer)b_vs_oo_},
    {"vs_oob_", (MethodPointer)b_vs_oob_},
    {"vs_oooObr4r4r4r4bb_", (MethodPointer)b_vs_oooObr4r4r4r4bb_},
    {"vs_ossi4i4i4i4o_", (MethodPointer)b_vs_ossi4i4i4i4o_},
    {"vs_pi4_", (MethodPointer)b_vs_pi4_},
    {"vs_pi4_o", (MethodPointer)b_vs_pi4_o},
    {"vs_ppi4i4_o", (MethodPointer)b_vs_ppi4i4_o},
    {"vs_pu4_", (MethodPointer)b_vs_pu4_},
    {"vs_r4r4_", (MethodPointer)b_vs_r4r4_},
    {"vs_r4r4oi4_", (MethodPointer)b_vs_r4r4oi4_},
    {"vs_r4r4r4_", (MethodPointer)b_vs_r4r4r4_},
    {"vs_r4r4r4r4_", (MethodPointer)b_vs_r4r4r4r4_},
    {"vs_r4r4r4r4_i4", (MethodPointer)b_vs_r4r4r4r4_i4},
    {"vs_r4r4r4r4_i4bb", (MethodPointer)b_vs_r4r4r4r4_i4bb},
    {"vs_r4r4r4r4_o", (MethodPointer)b_vs_r4r4r4r4_o},
    {"vs_r4r4r4r4_oo", (MethodPointer)b_vs_r4r4r4r4_oo},
    {"vs_so_", (MethodPointer)b_vs_so_},
    {"vs_soo_", (MethodPointer)b_vs_soo_},
    {"vs_ss_", (MethodPointer)b_vs_ss_},
    {"vs_u8_", (MethodPointer)b_vs_u8_},
    {"vs_u8b_", (MethodPointer)b_vs_u8b_},
    {"vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_},
    {"vsb", (MethodPointer)b_vsb},
    {"vsbs", (MethodPointer)b_vsbs},
    {"vsbs_Pvi4i4i4pi4i4oi4i4i4i4_", (MethodPointer)b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_},
    {"vsi4", (MethodPointer)b_vsi4},
    {"vso", (MethodPointer)b_vso},
    {"vsoo", (MethodPointer)b_vsoo},
    {"vss", (MethodPointer)b_vss},
    {"vss_r4r4r4r4_", (MethodPointer)b_vss_r4r4r4r4_},
    {"vssi4", (MethodPointer)b_vssi4},
    {"vsso", (MethodPointer)b_vsso},
    {"vu1", (MethodPointer)b_vu1},
    {"vu4u4Ps_ppi4i4p_", (MethodPointer)b_vu4u4Ps_ppi4i4p_},
    {"vu8o", (MethodPointer)b_vu8o},
    {nullptr, nullptr}
};


static void ifg_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_i4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    int32_t ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_i4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_o(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_o");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    void* ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
}

static void ifs_o(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_o");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(nullptr, fieldInfo, offset, p);
}

static void ifg_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_r4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    float ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_r4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    void* ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal s
    v8::String::Utf8Value tp(isolate, info[0]);
    void* p = CStringToCSharpString(*tp);
    FieldSet(nullptr, fieldInfo, offset, p);
}

static void ifg_tb(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tb");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    bool ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tb(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tb");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    bool p = converter::Converter<bool>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int32_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ti4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_to");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
}

static void ifs_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_to");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tr4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    float ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tr4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_ts(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal s
    v8::String::Utf8Value tp(isolate, info[0]);
    void* p = CStringToCSharpString(*tp);
    FieldSet(self, fieldInfo, offset, &p);
}

static FieldWrapFuncInfo g_fieldWrapFuncInfos[] = {
    
    {"i4", ifg_i4, ifs_i4},
    {"o", ifg_o, ifs_o},
    {"r4", ifg_r4, ifs_r4},
    {"s", ifg_s, ifs_s},
    {"tb", ifg_tb, ifs_tb},
    {"ti4", ifg_ti4, ifs_ti4},
    {"to", ifg_to, ifs_to},
    {"tr4", ifg_tr4, ifs_tr4},
    {"ts", ifg_ts, ifs_ts},
    {nullptr, nullptr, nullptr}    
};

